// Package Swagger provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package main

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/pkg/errors"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// AdditionalItem defines model for AdditionalItem.
type AdditionalItem struct {
	Icon  *string `json:"icon,omitempty"`
	Title *string `json:"title,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Address defines model for Address.
type Address struct {
	Ip   *string `json:"ip,omitempty"`
	Kind *string `json:"kind,omitempty"`
	Name *string `json:"name,omitempty"`
}

// Addresses defines model for Addresses.
type Addresses []Address

// Aggregation defines model for Aggregation.
type Aggregation struct {
	DisplayName *string `json:"displayName,omitempty"`
	Label       *string `json:"label,omitempty"`
}

// App defines model for App.
type App struct {

	// Name of the application
	Name string `json:"name"`

	// A Namespace provide a scope for names
	// This type is used to describe a set of objects.
	Namespace Namespace `json:"namespace"`

	// Runtimes and associated dashboards
	Runtimes *[]Runtime `json:"runtimes,omitempty"`

	// List of service names linked with an application
	ServiceNames []string `json:"serviceNames"`

	// Workloads for a given application
	Workloads []WorkloadItem `json:"workloads"`
}

// AppHealth defines model for AppHealth.
type AppHealth struct {

	// RequestHealth holds several stats about recent request errors
	Requests         *RequestHealth    `json:"requests,omitempty"`
	WorkloadStatuses *[]WorkloadStatus `json:"workloadStatuses,omitempty"`
}

// AppList defines model for AppList.
type AppList struct {

	// Applications for a given namespace
	Applications []AppListItem `json:"applications"`

	// A Namespace provide a scope for names
	// This type is used to describe a set of objects.
	Namespace Namespace `json:"namespace"`
}

// AppListItem defines model for AppListItem.
type AppListItem struct {

	// Define if all Pods related to the Workloads of this app has an IstioSidecar deployed
	IstioSidecar bool `json:"istioSidecar"`

	// Labels for App
	Labels *AppListItem_Labels `json:"labels,omitempty"`

	// Name of the application
	Name string `json:"name"`
}

// AppListItem_Labels defines model for AppListItem.Labels.
type AppListItem_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CauseType defines model for CauseType.
type CauseType string

// Chart defines model for Chart.
type Chart struct {
	ChartType *string          `json:"chartType,omitempty"`
	Error     *string          `json:"error,omitempty"`
	Histogram *Chart_Histogram `json:"histogram,omitempty"`
	Max       *int64           `json:"max,omitempty"`
	Metric    *[]SampleStream  `json:"metric,omitempty"`
	Min       *int64           `json:"min,omitempty"`
	Name      *string          `json:"name,omitempty"`
	Spans     *int64           `json:"spans,omitempty"`
	Unit      *string          `json:"unit,omitempty"`
}

// Chart_Histogram defines model for Chart.Histogram.
type Chart_Histogram struct {
	AdditionalProperties map[string][]SampleStream `json:"-"`
}

// ClusterRbacConfig defines model for ClusterRbacConfig.
type ClusterRbacConfig struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta            `json:"metadata,omitempty"`
	Spec     *ClusterRbacConfigSpec `json:"spec,omitempty"`
}

// ClusterRbacConfigSpec defines model for ClusterRbacConfigSpec.
type ClusterRbacConfigSpec struct {
	Exclusion *map[string]interface{} `json:"exclusion,omitempty"`
	Inclusion *map[string]interface{} `json:"inclusion,omitempty"`
	Mode      *map[string]interface{} `json:"mode,omitempty"`
}

// ClusterRbacConfigs defines model for ClusterRbacConfigs.
type ClusterRbacConfigs []ClusterRbacConfig

// Config defines model for Config.
type Config struct {
	Duration  *int64    `json:"duration,omitempty"`
	Elements  *Elements `json:"elements,omitempty"`
	GraphType *string   `json:"graphType,omitempty"`
	Timestamp *int64    `json:"timestamp,omitempty"`
}

// ContainerInfo defines model for ContainerInfo.
type ContainerInfo struct {
	Image *string `json:"image,omitempty"`
	Name  *string `json:"name,omitempty"`
}

// DashboardRef defines model for DashboardRef.
type DashboardRef struct {
	Template *string `json:"template,omitempty"`
	Title    *string `json:"title,omitempty"`
}

// EdgeData defines model for EdgeData.
type EdgeData struct {

	// Cytoscape Fields
	Id           *string `json:"id,omitempty"`
	IsMTLS       *string `json:"isMTLS,omitempty"`
	ResponseTime *string `json:"responseTime,omitempty"`
	Source       *string `json:"source,omitempty"`
	Target       *string `json:"target,omitempty"`

	// ProtocolTraffic supplies all of the traffic information for a single protocol
	Traffic *ProtocolTraffic `json:"traffic,omitempty"`
}

// EdgeWrapper defines model for EdgeWrapper.
type EdgeWrapper struct {
	Data *EdgeData `json:"data,omitempty"`
}

// Elements defines model for Elements.
type Elements struct {
	Edges *[]EdgeWrapper `json:"edges,omitempty"`
	Nodes *[]NodeWrapper `json:"nodes,omitempty"`
}

// Endpoint defines model for Endpoint.
type Endpoint struct {
	Addresses *Addresses `json:"addresses,omitempty"`
	Ports     *Ports     `json:"ports,omitempty"`
}

// Endpoints defines model for Endpoints.
type Endpoints []Endpoint

// ExternalLink defines model for ExternalLink.
type ExternalLink struct {
	Name      *string                                   `json:"name,omitempty"`
	Url       *string                                   `json:"url,omitempty"`
	Variables *MonitoringDashboardExternalLinkVariables `json:"variables,omitempty"`
}

// Fields defines model for Fields.
type Fields struct {

	// Map stores a set of fields in a data structure like a Trie.
	//
	// Each key is either a '.' representing the field itself, and will always map to an empty set,
	// or a string representing a sub-field or item. The string will follow one of these four formats:
	// 'f:<name>', where <name> is the name of a field in a struct, or key in a map
	// 'v:<value>', where <value> is the exact json formatted value of a list item
	// 'i:<index>', where <index> is position of a item in a list
	// 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values
	// If a key maps to an empty Fields value, the field that key represents is part of the set.
	//
	// The exact format is defined in k8s.io/apiserver/pkg/endpoints/handlers/fieldmanager/internal
	Map *Fields_Map `json:"Map,omitempty"`
}

// Fields_Map defines model for Fields.Map.
type Fields_Map struct {
	AdditionalProperties map[string]Fields `json:"-"`
}

// Gateway defines model for Gateway.
type Gateway struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		Selector *map[string]interface{} `json:"selector,omitempty"`
		Servers  *map[string]interface{} `json:"servers,omitempty"`
	} `json:"spec,omitempty"`
}

// Gateways defines model for Gateways.
type Gateways []Gateway

// GrafanaInfo defines model for GrafanaInfo.
type GrafanaInfo struct {
	ExternalLinks *[]ExternalLink `json:"externalLinks,omitempty"`
}

// Initializer defines model for Initializer.
type Initializer struct {

	// name of the process that is responsible for initializing this object.
	Name *string `json:"name,omitempty"`
}

// Initializers defines model for Initializers.
type Initializers struct {

	// Pending is a list of initializers that must execute in order before this object is visible.
	// When the last pending initializer is removed, and no failing result is set, the initializers
	// struct will be set to nil and the object is considered as initialized and visible to all
	// clients.
	// +patchMergeKey=name
	// +patchStrategy=merge
	Pending *[]Initializer `json:"pending,omitempty"`
	Result  *Status        `json:"result,omitempty"`
}

// IstioCheck defines model for IstioCheck.
type IstioCheck struct {

	// Description of the check
	Message string `json:"message"`

	// String that describes where in the yaml file is the check located
	Path     *string       `json:"path,omitempty"`
	Severity SeverityLevel `json:"severity"`
}

// IstioConfigDetails defines model for IstioConfigDetails.
type IstioConfigDetails struct {

	// This type type is used for returning a IstioAdapter
	Adapter *IstioAdapter `json:"adapter,omitempty"`

	// This is used for returning an AuthorizationPolicy
	AuthorizationPolicy *AuthorizationPolicy `json:"authorizationPolicy,omitempty"`
	ClusterRbacConfig   *ClusterRbacConfig   `json:"clusterRbacConfig,omitempty"`

	// This is used for returning a DestinationRule
	DestinationRule *DestinationRule `json:"destinationRule,omitempty"`
	Gateway         *Gateway         `json:"gateway,omitempty"`
	MeshPolicy      *MeshPolicy      `json:"meshPolicy,omitempty"`

	// A Namespace provide a scope for names
	// This type is used to describe a set of objects.
	Namespace  *Namespace `json:"namespace,omitempty"`
	ObjectType *string    `json:"objectType,omitempty"`

	// ResourcePermissions holds permission flags for an object type
	// True means allowed.
	Permissions      *ResourcePermissions `json:"permissions,omitempty"`
	Policy           *Policy              `json:"policy,omitempty"`
	QuotaSpec        *QuotaSpec           `json:"quotaSpec,omitempty"`
	QuotaSpecBinding *QuotaSpecBinding    `json:"quotaSpecBinding,omitempty"`
	RbacConfig       *RbacConfig          `json:"rbacConfig,omitempty"`

	// This type type is used for returning a IstioRule
	Rule                  *IstioRule             `json:"rule,omitempty"`
	ServiceEntry          *ServiceEntry          `json:"serviceEntry,omitempty"`
	ServiceMeshPolicy     *ServiceMeshPolicy     `json:"serviceMeshPolicy,omitempty"`
	ServiceMeshRbacConfig *ServiceMeshRbacConfig `json:"serviceMeshRbacConfig,omitempty"`
	ServiceRole           *ServiceRole           `json:"serviceRole,omitempty"`
	ServiceRoleBinding    *ServiceRoleBinding    `json:"serviceRoleBinding,omitempty"`
	Sidecar               *Sidecar               `json:"sidecar,omitempty"`

	// This type type is used for returning a IstioTemplate
	Template   *IstioTemplate   `json:"template,omitempty"`
	Validation *IstioValidation `json:"validation,omitempty"`

	// This type is used for returning a VirtualService
	VirtualService *VirtualService `json:"virtualService,omitempty"`
}

// IstioConfigList defines model for IstioConfigList.
type IstioConfigList struct {

	// This type type is used for returning an array of IstioAdapters
	Adapters *IstioAdapters `json:"adapters,omitempty"`

	// This is used for returning an array of AuthorizationPolicies
	AuthorizationPolicies *AuthorizationRules `json:"authorizationPolicies,omitempty"`
	ClusterRbacConfigs    *ClusterRbacConfigs `json:"clusterRbacConfigs,omitempty"`

	// This is used for returning an array of DestinationRules
	DestinationRules *DestinationRules `json:"destinationRules,omitempty"`
	Gateways         *Gateways         `json:"gateways,omitempty"`
	MeshPolicies     *MeshPolicies     `json:"meshPolicies,omitempty"`

	// A Namespace provide a scope for names
	// This type is used to describe a set of objects.
	Namespace         Namespace          `json:"namespace"`
	Policies          *Policies          `json:"policies,omitempty"`
	QuotaSpecBindings *QuotaSpecBindings `json:"quotaSpecBindings,omitempty"`
	QuotaSpecs        *QuotaSpecs        `json:"quotaSpecs,omitempty"`
	RbacConfigs       *RbacConfigs       `json:"rbacConfigs,omitempty"`

	// This type type is used for returning an array of IstioRules
	Rules                  *IstioRules             `json:"rules,omitempty"`
	ServiceEntries         *ServiceEntries         `json:"serviceEntries,omitempty"`
	ServiceMeshPolicies    *ServiceMeshPolicies    `json:"serviceMeshPolicies,omitempty"`
	ServiceMeshRbacConfigs *ServiceMeshRbacConfigs `json:"serviceMeshRbacConfigs,omitempty"`
	ServiceRoleBindings    *ServiceRoleBindings    `json:"serviceRoleBindings,omitempty"`
	ServiceRoles           *ServiceRoles           `json:"serviceRoles,omitempty"`
	Sidecars               *Sidecars               `json:"sidecars,omitempty"`

	// This type type is used for returning an array of IstioTemplates
	Templates   *IstioTemplates   `json:"templates,omitempty"`
	Validations *IstioValidations `json:"validations,omitempty"`

	// This type is used for returning an array of VirtualServices with some permission flags
	VirtualServices *VirtualServices `json:"virtualServices,omitempty"`
}

// IstioConfigPermissions defines model for IstioConfigPermissions.
type IstioConfigPermissions struct {
	AdditionalProperties map[string]ResourcesPermissions `json:"-"`
}

// IstioValidation defines model for IstioValidation.
type IstioValidation struct {

	// Array of checks. It might be empty.
	Checks *[]IstioCheck `json:"checks,omitempty"`

	// Name of the object itself
	Name string `json:"name"`

	// Type of the object
	ObjectType string `json:"objectType"`

	// Related objects (only validation errors)
	References *[]IstioValidationKey `json:"references,omitempty"`

	// Represents validity of the object: in case of warning, validity remains as true
	Valid bool `json:"valid"`
}

// IstioValidationKey defines model for IstioValidationKey.
type IstioValidationKey struct {
	Name       *string `json:"name,omitempty"`
	Namespace  *string `json:"namespace,omitempty"`
	ObjectType *string `json:"objectType,omitempty"`
}

// IstioValidationSummary defines model for IstioValidationSummary.
type IstioValidationSummary struct {

	// Number of validations with error severity
	Errors int64 `json:"errors"`

	// Number of Istio Objects analyzed
	ObjectCount int64 `json:"objectCount"`

	// Number of validations with warning severity
	Warnings int64 `json:"warnings"`
}

// IstioValidations defines model for IstioValidations.
type IstioValidations interface{}

// Iter8Criteria defines model for Iter8Criteria.
type Iter8Criteria struct {
	Metric        *string  `json:"metric,omitempty"`
	SampleSize    *int64   `json:"sampleSize,omitempty"`
	StopOnFailure *bool    `json:"stopOnFailure,omitempty"`
	Tolerance     *float64 `json:"tolerance,omitempty"`
	ToleranceType *string  `json:"toleranceType,omitempty"`
}

// Iter8CriteriaDetail defines model for Iter8CriteriaDetail.
type Iter8CriteriaDetail struct {
	Criteria *Iter8Criteria `json:"criteria,omitempty"`
	Metric   *Iter8Metric   `json:"metric,omitempty"`
	Name     *string        `json:"name,omitempty"`
}

// Iter8ExperimentDetail defines model for Iter8ExperimentDetail.
type Iter8ExperimentDetail struct {
	Criterias      *[]Iter8CriteriaDetail `json:"criterias,omitempty"`
	ExperimentItem *Iter8ExperimentItem   `json:"experimentItem,omitempty"`
	TrafficControl *Iter8TrafficControl   `json:"trafficControl,omitempty"`
}

// Iter8ExperimentItem defines model for Iter8ExperimentItem.
type Iter8ExperimentItem struct {
	AssessmentConclusion   *string `json:"assessmentConclusion,omitempty"`
	Baseline               *string `json:"baseline,omitempty"`
	BaselinePercentage     *int64  `json:"baselinePercentage,omitempty"`
	Candidate              *string `json:"candidate,omitempty"`
	CandidatePercentage    *int64  `json:"candidatePercentage,omitempty"`
	CreatedAt              *string `json:"createdAt,omitempty"`
	EndedAt                *string `json:"endedAt,omitempty"`
	Name                   *string `json:"name,omitempty"`
	Namespace              *string `json:"namespace,omitempty"`
	Phase                  *string `json:"phase,omitempty"`
	StartedAt              *string `json:"startedAt,omitempty"`
	Status                 *string `json:"status,omitempty"`
	TargetService          *string `json:"targetService,omitempty"`
	TargetServiceNamespace *string `json:"targetServiceNamespace,omitempty"`
}

// Iter8Info defines model for Iter8Info.
type Iter8Info struct {
	Enabled *bool `json:"enabled,omitempty"`

	// ResourcePermissions holds permission flags for an object type
	// True means allowed.
	Permissions *ResourcePermissions `json:"permissions,omitempty"`
}

// Iter8Metric defines model for Iter8Metric.
type Iter8Metric struct {
	AbsentValue        *string `json:"absent_value,omitempty"`
	IsCounter          *bool   `json:"is_counter,omitempty"`
	QueryTemplate      *string `json:"query_template,omitempty"`
	SampleSizeTemplate *string `json:"sample_size_template,omitempty"`
}

// Iter8TrafficControl defines model for Iter8TrafficControl.
type Iter8TrafficControl struct {
	Algorithm            *string  `json:"algorithm,omitempty"`
	Interval             *string  `json:"interval,omitempty"`
	MaxIteration         *int64   `json:"maxIteration,omitempty"`
	MaxTrafficPercentage *float64 `json:"maxTrafficPercentage,omitempty"`
	TrafficStepSize      *float64 `json:"trafficStepSize,omitempty"`
}

// JaegerInfo defines model for JaegerInfo.
type JaegerInfo struct {
	Enabled              *bool     `json:"enabled,omitempty"`
	Integration          *bool     `json:"integration,omitempty"`
	NamespaceSelector    *bool     `json:"namespaceSelector,omitempty"`
	Url                  *string   `json:"url,omitempty"`
	WhiteListIstioSystem *[]string `json:"whiteListIstioSystem,omitempty"`
}

// KeyValue defines model for KeyValue.
type KeyValue struct {
	Key   *string                 `json:"key,omitempty"`
	Type  *ValueType              `json:"type,omitempty"`
	Value *map[string]interface{} `json:"value,omitempty"`
}

// Log defines model for Log.
type Log struct {
	Fields    *[]KeyValue `json:"fields,omitempty"`
	Timestamp *int        `json:"timestamp,omitempty"`
}

// MTLSStatus defines model for MTLSStatus.
type MTLSStatus struct {

	// mTLS status: MTLS_ENABLED, MTLS_PARTIALLY_ENABLED, MTLS_NOT_ENABLED
	Status string `json:"status"`
}

// ManagedFieldsEntry defines model for ManagedFieldsEntry.
type ManagedFieldsEntry struct {

	// APIVersion defines the version of this resource that this field set
	// applies to. The format is "group/version" just like the top-level
	// APIVersion field. It is necessary to track the version of a field
	// set because it cannot be automatically converted.
	ApiVersion *string `json:"apiVersion,omitempty"`

	// To understand how this is used, see: https://github.com/kubernetes-sigs/structured-merge-diff
	Fields *Fields `json:"fields,omitempty"`

	// Manager is an identifier of the workflow managing these fields.
	Manager   *string                     `json:"manager,omitempty"`
	Operation *ManagedFieldsOperationType `json:"operation,omitempty"`

	// +protobuf.options.marshal=false
	// +protobuf.as=Timestamp
	// +protobuf.options.(gogoproto.goproto_stringer)=false
	Time *Time `json:"time,omitempty"`
}

// ManagedFieldsOperationType defines model for ManagedFieldsOperationType.
type ManagedFieldsOperationType string

// Matrix defines model for Matrix.
type Matrix []SampleStream

// MeshPolicies defines model for MeshPolicies.
type MeshPolicies []MeshPolicy

// MeshPolicy defines model for MeshPolicy.
type MeshPolicy struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta     `json:"metadata,omitempty"`
	Spec     *MeshPolicySpec `json:"spec,omitempty"`
}

// MeshPolicySpec defines model for MeshPolicySpec.
type MeshPolicySpec struct {
	OriginIsOptional *map[string]interface{} `json:"originIsOptional,omitempty"`
	Origins          *map[string]interface{} `json:"origins,omitempty"`
	PeerIsOptional   *map[string]interface{} `json:"peerIsOptional,omitempty"`
	Peers            *map[string]interface{} `json:"peers,omitempty"`
	PrincipalBinding *map[string]interface{} `json:"principalBinding,omitempty"`
	Targets          *map[string]interface{} `json:"targets,omitempty"`
}

// Metric defines model for Metric.
type Metric struct {
	Matrix *Matrix `json:"matrix,omitempty"`
}

// Metrics defines model for Metrics.
type Metrics struct {
	Histograms *Metrics_Histograms `json:"histograms,omitempty"`
	Metrics    *Metrics_Metrics    `json:"metrics,omitempty"`
}

// Metrics_Histograms defines model for Metrics.Histograms.
type Metrics_Histograms struct {
	AdditionalProperties map[string]struct {
		AdditionalProperties map[string]Metric `json:"-"`
	} `json:"-"`
}

// Metrics_Metrics defines model for Metrics.Metrics.
type Metrics_Metrics struct {
	AdditionalProperties map[string]Metric `json:"-"`
}

// MonitoringDashboard defines model for MonitoringDashboard.
type MonitoringDashboard struct {
	Aggregations  *[]Aggregation  `json:"aggregations,omitempty"`
	Charts        *[]Chart        `json:"charts,omitempty"`
	ExternalLinks *[]ExternalLink `json:"externalLinks,omitempty"`
	Title         *string         `json:"title,omitempty"`
}

// MonitoringDashboardExternalLinkVariables defines model for MonitoringDashboardExternalLinkVariables.
type MonitoringDashboardExternalLinkVariables struct {
	App       *string `json:"app,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
	Service   *string `json:"service,omitempty"`
	Version   *string `json:"version,omitempty"`
	Workload  *string `json:"workload,omitempty"`
}

// NamespaceAppHealth defines model for NamespaceAppHealth.
type NamespaceAppHealth struct {
	AdditionalProperties map[string]AppHealth `json:"-"`
}

// NodeData defines model for NodeData.
type NodeData struct {
	App          *string        `json:"app,omitempty"`
	DestServices *[]ServiceName `json:"destServices,omitempty"`
	HasCB        *bool          `json:"hasCB,omitempty"`
	HasMissingSC *bool          `json:"hasMissingSC,omitempty"`
	HasVS        *bool          `json:"hasVS,omitempty"`

	// Cytoscape Fields
	Id              *string `json:"id,omitempty"`
	IsDead          *bool   `json:"isDead,omitempty"`
	IsGroup         *string `json:"isGroup,omitempty"`
	IsInaccessible  *bool   `json:"isInaccessible,omitempty"`
	IsMisconfigured *string `json:"isMisconfigured,omitempty"`
	IsOutside       *bool   `json:"isOutside,omitempty"`
	IsRoot          *bool   `json:"isRoot,omitempty"`
	IsServiceEntry  *string `json:"isServiceEntry,omitempty"`
	IsUnused        *bool   `json:"isUnused,omitempty"`
	Namespace       *string `json:"namespace,omitempty"`

	// App Fields (not required by Cytoscape)
	NodeType *string            `json:"nodeType,omitempty"`
	Parent   *string            `json:"parent,omitempty"`
	Service  *string            `json:"service,omitempty"`
	Traffic  *[]ProtocolTraffic `json:"traffic,omitempty"`
	Version  *string            `json:"version,omitempty"`
	Workload *string            `json:"workload,omitempty"`
}

// NodeWrapper defines model for NodeWrapper.
type NodeWrapper struct {
	Data *NodeData `json:"data,omitempty"`
}

// ObjectMeta defines model for ObjectMeta.
type ObjectMeta struct {

	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: http://kubernetes.io/docs/user-guide/annotations
	// +optional
	Annotations *ObjectMeta_Annotations `json:"annotations,omitempty"`

	// The name of the cluster which the object belongs to.
	// This is used to distinguish resources with same name and namespace in different clusters.
	// This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
	// +optional
	ClusterName *string `json:"clusterName,omitempty"`

	// +protobuf.options.marshal=false
	// +protobuf.as=Timestamp
	// +protobuf.options.(gogoproto.goproto_stringer)=false
	CreationTimestamp *Time `json:"creationTimestamp,omitempty"`

	// Number of seconds allowed for this object to gracefully terminate before
	// it will be removed from the system. Only set when deletionTimestamp is also set.
	// May only be shortened.
	// Read-only.
	// +optional
	DeletionGracePeriodSeconds *int64 `json:"deletionGracePeriodSeconds,omitempty"`

	// +protobuf.options.marshal=false
	// +protobuf.as=Timestamp
	// +protobuf.options.(gogoproto.goproto_stringer)=false
	DeletionTimestamp *Time `json:"deletionTimestamp,omitempty"`

	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	// +optional
	// +patchStrategy=merge
	Finalizers *[]string `json:"finalizers,omitempty"`

	// GenerateName is an optional prefix, used by the server, to generate a unique
	// name ONLY IF the Name field has not been provided.
	// If this field is used, the name returned to the client will be different
	// than the name passed. This value will also be combined with a unique suffix.
	// The provided value has the same validation rules as the Name field,
	// and may be truncated by the length of the suffix required to make the value
	// unique on the server.
	//
	// If this field is specified and the generated name exists, the server will
	// NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
	// ServerTimeout indicating a unique name could not be found in the time allotted, and the client
	// should retry (optionally after the time indicated in the Retry-After header).
	//
	// Applied only if Name is not specified.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency
	// +optional
	GenerateName *string `json:"generateName,omitempty"`

	// A sequence number representing a specific generation of the desired state.
	// Populated by the system. Read-only.
	// +optional
	Generation   *int64        `json:"generation,omitempty"`
	Initializers *Initializers `json:"initializers,omitempty"`

	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	// More info: http://kubernetes.io/docs/user-guide/labels
	// +optional
	Labels *ObjectMeta_Labels `json:"labels,omitempty"`

	// ManagedFields maps workflow-id and version to the set of fields
	// that are managed by that workflow. This is mostly for internal
	// housekeeping, and users typically shouldn't need to set or
	// understand this field. A workflow can be the user's name, a
	// controller's name, or the name of a specific apply path like
	// "ci-cd". The set of fields is always in the version that the
	// workflow used when modifying the object.
	//
	// This field is alpha and can be changed or removed without notice.
	//
	// +optional
	ManagedFields *[]ManagedFieldsEntry `json:"managedFields,omitempty"`

	// Name must be unique within a namespace. Is required when creating resources, although
	// some resources may allow a client to request the generation of an appropriate name
	// automatically. Name is primarily intended for creation idempotence and configuration
	// definition.
	// Cannot be updated.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#names
	// +optional
	Name *string `json:"name,omitempty"`

	// Namespace defines the space within each name must be unique. An empty namespace is
	// equivalent to the "default" namespace, but "default" is the canonical representation.
	// Not all objects are required to be scoped to a namespace - the value of this field for
	// those objects will be empty.
	//
	// Must be a DNS_LABEL.
	// Cannot be updated.
	// More info: http://kubernetes.io/docs/user-guide/namespaces
	// +optional
	Namespace *string `json:"namespace,omitempty"`

	// List of objects depended by this object. If ALL objects in the list have
	// been deleted, this object will be garbage collected. If this object is managed by a controller,
	// then an entry in this list will point to this controller, with the controller field set to true.
	// There cannot be more than one managing controller.
	// +optional
	// +patchMergeKey=uid
	// +patchStrategy=merge
	OwnerReferences *[]OwnerReference `json:"ownerReferences,omitempty"`

	// An opaque value that represents the internal version of this object that can
	// be used by clients to determine when objects have changed. May be used for optimistic
	// concurrency, change detection, and the watch operation on a resource or set of resources.
	// Clients must treat these values as opaque and passed unmodified back to the server.
	// They may only be valid for a particular resource or set of resources.
	//
	// Populated by the system.
	// Read-only.
	// Value must be treated as opaque by clients and .
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	// +optional
	ResourceVersion *string `json:"resourceVersion,omitempty"`

	// SelfLink is a URL representing this object.
	// Populated by the system.
	// Read-only.
	// +optional
	SelfLink *string `json:"selfLink,omitempty"`

	// UID is a type that holds unique ID values, including UUIDs.  Because we
	// don't ONLY use UUIDs, this is an alias to string.  Being a type captures
	// intent and helps make sure that UIDs and names do not get conflated.
	Uid *UID `json:"uid,omitempty"`
}

// ObjectMeta_Annotations defines model for ObjectMeta.Annotations.
type ObjectMeta_Annotations struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ObjectMeta_Labels defines model for ObjectMeta.Labels.
type ObjectMeta_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// OwnerReference defines model for OwnerReference.
type OwnerReference struct {

	// API version of the referent.
	ApiVersion *string `json:"apiVersion,omitempty"`

	// If true, AND if the owner has the "foregroundDeletion" finalizer, then
	// the owner cannot be deleted from the key-value store until this
	// reference is removed.
	// Defaults to false.
	// To set this field, a user needs "delete" permission of the owner,
	// otherwise 422 (Unprocessable Entity) will be returned.
	// +optional
	BlockOwnerDeletion *bool `json:"blockOwnerDeletion,omitempty"`

	// If true, this reference points to the managing controller.
	// +optional
	Controller *bool `json:"controller,omitempty"`

	// Kind of the referent.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind *string `json:"kind,omitempty"`

	// Name of the referent.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#names
	Name *string `json:"name,omitempty"`

	// UID is a type that holds unique ID values, including UUIDs.  Because we
	// don't ONLY use UUIDs, this is an alias to string.  Being a type captures
	// intent and helps make sure that UIDs and names do not get conflated.
	Uid *UID `json:"uid,omitempty"`
}

// Pod defines model for Pod.
type Pod struct {
	Annotations         *Pod_Annotations `json:"annotations,omitempty"`
	AppLabel            *bool            `json:"appLabel,omitempty"`
	Containers          *[]ContainerInfo `json:"containers,omitempty"`
	CreatedAt           *string          `json:"createdAt,omitempty"`
	CreatedBy           *[]Reference     `json:"createdBy,omitempty"`
	IstioContainers     *[]ContainerInfo `json:"istioContainers,omitempty"`
	IstioInitContainers *[]ContainerInfo `json:"istioInitContainers,omitempty"`
	Labels              *Pod_Labels      `json:"labels,omitempty"`
	Name                *string          `json:"name,omitempty"`
	Status              *string          `json:"status,omitempty"`
	VersionLabel        *bool            `json:"versionLabel,omitempty"`
}

// Pod_Annotations defines model for Pod.Annotations.
type Pod_Annotations struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Pod_Labels defines model for Pod.Labels.
type Pod_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Pods defines model for Pods.
type Pods []Pod

// Policies defines model for Policies.
type Policies []Policy

// Policy defines model for Policy.
type Policy struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		OriginIsOptional *map[string]interface{} `json:"originIsOptional,omitempty"`
		Origins          *map[string]interface{} `json:"origins,omitempty"`
		PeerIsOptional   *map[string]interface{} `json:"peerIsOptional,omitempty"`
		Peers            *map[string]interface{} `json:"peers,omitempty"`
		PrincipalBinding *map[string]interface{} `json:"principalBinding,omitempty"`
		Targets          *map[string]interface{} `json:"targets,omitempty"`
	} `json:"spec,omitempty"`
}

// Port defines model for Port.
type Port struct {
	Name     *string `json:"name,omitempty"`
	Port     *int32  `json:"port,omitempty"`
	Protocol *string `json:"protocol,omitempty"`
}

// Ports defines model for Ports.
type Ports []Port

// Process defines model for Process.
type Process struct {
	ServiceName *string     `json:"serviceName,omitempty"`
	Tags        *[]KeyValue `json:"tags,omitempty"`
}

// ProcessID defines model for ProcessID.
type ProcessID string

// ProtocolTraffic defines model for ProtocolTraffic.
type ProtocolTraffic struct {
	Protocol *string                `json:"protocol,omitempty"`
	Rates    *ProtocolTraffic_Rates `json:"rates,omitempty"`

	// Responses maps responseCodes to detailed information for that code
	Responses *Responses `json:"responses,omitempty"`
}

// ProtocolTraffic_Rates defines model for ProtocolTraffic.Rates.
type ProtocolTraffic_Rates struct {
	AdditionalProperties map[string]string `json:"-"`
}

// QuotaSpec defines model for QuotaSpec.
type QuotaSpec struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		Rules *map[string]interface{} `json:"rules,omitempty"`
	} `json:"spec,omitempty"`
}

// QuotaSpecBinding defines model for QuotaSpecBinding.
type QuotaSpecBinding struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		QuotaSpecs *map[string]interface{} `json:"quotaSpecs,omitempty"`
		Services   *map[string]interface{} `json:"services,omitempty"`
	} `json:"spec,omitempty"`
}

// QuotaSpecBindings defines model for QuotaSpecBindings.
type QuotaSpecBindings []QuotaSpecBinding

// QuotaSpecs defines model for QuotaSpecs.
type QuotaSpecs []QuotaSpec

// RbacConfig defines model for RbacConfig.
type RbacConfig struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		Exclusion *map[string]interface{} `json:"exclusion,omitempty"`
		Inclusion *map[string]interface{} `json:"inclusion,omitempty"`
		Mode      *map[string]interface{} `json:"mode,omitempty"`
	} `json:"spec,omitempty"`
}

// RbacConfigs defines model for RbacConfigs.
type RbacConfigs []RbacConfig

// Reference defines model for Reference.
type Reference struct {

	// ReferenceType is the reference type of one span to another
	RefType *ReferenceType `json:"refType,omitempty"`

	// SpanID is the id of a span
	SpanID  *SpanID  `json:"spanID,omitempty"`
	TraceID *TraceID `json:"traceID,omitempty"`
}

// ReferenceType defines model for ReferenceType.
type ReferenceType string

// RequestHealth defines model for RequestHealth.
type RequestHealth struct {
	ErrorRatio         *float64 `json:"errorRatio,omitempty"`
	InboundErrorRatio  *float64 `json:"inboundErrorRatio,omitempty"`
	OutboundErrorRatio *float64 `json:"outboundErrorRatio,omitempty"`
}

// ResourcePermissions defines model for ResourcePermissions.
type ResourcePermissions struct {
	Create *bool `json:"create,omitempty"`
	Delete *bool `json:"delete,omitempty"`
	Update *bool `json:"update,omitempty"`
}

// ResourcesPermissions defines model for ResourcesPermissions.
type ResourcesPermissions struct {
	AdditionalProperties map[string]ResourcePermissions `json:"-"`
}

// ResponseDetail defines model for ResponseDetail.
type ResponseDetail struct {

	// "200" : {
	// "-"     : "80.0",
	// "DC"    : "10.0",
	// "FI,FD" : "10.0"
	// }, ...
	Flags *ResponseFlags `json:"flags,omitempty"`

	// "200" : {
	// "www.google.com" : "80.0",
	// "www.yahoo.com"  : "20.0"
	// }, ...
	Hosts *ResponseHosts `json:"hosts,omitempty"`
}

// ResponseFlags defines model for ResponseFlags.
type ResponseFlags struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ResponseHosts defines model for ResponseHosts.
type ResponseHosts struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Responses defines model for Responses.
type Responses struct {
	AdditionalProperties map[string]ResponseDetail `json:"-"`
}

// Runtime defines model for Runtime.
type Runtime struct {
	DashboardRefs *[]DashboardRef `json:"dashboardRefs,omitempty"`
	Name          *string         `json:"name,omitempty"`
}

// SamplePair defines model for SamplePair.
type SamplePair struct {
	Timestamp *int64   `json:"Timestamp,omitempty"`
	Value     *float64 `json:"Value,omitempty"`
}

// SampleStream defines model for SampleStream.
type SampleStream struct {
	LabelSet *SampleStream_LabelSet `json:"labelSet,omitempty"`
	Values   *[]SamplePair          `json:"values,omitempty"`
}

// SampleStream_LabelSet defines model for SampleStream.LabelSet.
type SampleStream_LabelSet struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Service defines model for Service.
type Service struct {
	CreatedAt    *string         `json:"createdAt,omitempty"`
	ExternalName *string         `json:"externalName,omitempty"`
	Ip           *string         `json:"ip,omitempty"`
	Labels       *Service_Labels `json:"labels,omitempty"`
	Name         *string         `json:"name,omitempty"`

	// A Namespace provide a scope for names
	// This type is used to describe a set of objects.
	Namespace       *Namespace         `json:"namespace,omitempty"`
	Ports           *Ports             `json:"ports,omitempty"`
	ResourceVersion *string            `json:"resourceVersion,omitempty"`
	Selectors       *Service_Selectors `json:"selectors,omitempty"`
	Type            *string            `json:"type,omitempty"`
}

// Service_Labels defines model for Service.Labels.
type Service_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Service_Selectors defines model for Service.Selectors.
type Service_Selectors struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ServiceDetails defines model for ServiceDetails.
type ServiceDetails struct {
	AdditionalDetails *[]AdditionalItem `json:"additionalDetails,omitempty"`

	// This is used for returning an array of DestinationRules
	DestinationRules *DestinationRules `json:"destinationRules,omitempty"`
	Endpoints        *Endpoints        `json:"endpoints,omitempty"`

	// ServiceHealth contains aggregated health from various sources, for a given service
	Health       *ServiceHealth `json:"health,omitempty"`
	IstioSidecar *bool          `json:"istioSidecar,omitempty"`

	// MTLSStatus describes the current mTLS status of a mesh entity
	NamespaceMTLS *MTLSStatus       `json:"namespaceMTLS,omitempty"`
	Service       *Service          `json:"service,omitempty"`
	Validations   *IstioValidations `json:"validations,omitempty"`

	// This type is used for returning an array of VirtualServices with some permission flags
	VirtualServices *VirtualServices   `json:"virtualServices,omitempty"`
	Workloads       *WorkloadOverviews `json:"workloads,omitempty"`
}

// ServiceEntries defines model for ServiceEntries.
type ServiceEntries []ServiceEntry

// ServiceEntry defines model for ServiceEntry.
type ServiceEntry struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		Addresses       *map[string]interface{} `json:"addresses,omitempty"`
		Endpoints       *map[string]interface{} `json:"endpoints,omitempty"`
		ExportTo        *map[string]interface{} `json:"exportTo,omitempty"`
		Hosts           *map[string]interface{} `json:"hosts,omitempty"`
		Location        *map[string]interface{} `json:"location,omitempty"`
		Ports           *map[string]interface{} `json:"ports,omitempty"`
		Resolution      *map[string]interface{} `json:"resolution,omitempty"`
		SubjectAltNames *map[string]interface{} `json:"subjectAltNames,omitempty"`
	} `json:"spec,omitempty"`
}

// ServiceHealth defines model for ServiceHealth.
type ServiceHealth struct {

	// RequestHealth holds several stats about recent request errors
	Requests *RequestHealth `json:"requests,omitempty"`
}

// ServiceList defines model for ServiceList.
type ServiceList struct {

	// A Namespace provide a scope for names
	// This type is used to describe a set of objects.
	Namespace   *Namespace         `json:"namespace,omitempty"`
	Services    *[]ServiceOverview `json:"services,omitempty"`
	Validations *IstioValidations  `json:"validations,omitempty"`
}

// ServiceMeshPolicies defines model for ServiceMeshPolicies.
type ServiceMeshPolicies []ServiceMeshPolicy

// ServiceMeshPolicy defines model for ServiceMeshPolicy.
type ServiceMeshPolicy struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta     `json:"metadata,omitempty"`
	Spec     *MeshPolicySpec `json:"spec,omitempty"`
}

// ServiceMeshRbacConfig defines model for ServiceMeshRbacConfig.
type ServiceMeshRbacConfig struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta            `json:"metadata,omitempty"`
	Spec     *ClusterRbacConfigSpec `json:"spec,omitempty"`
}

// ServiceMeshRbacConfigs defines model for ServiceMeshRbacConfigs.
type ServiceMeshRbacConfigs []ServiceMeshRbacConfig

// ServiceName defines model for ServiceName.
type ServiceName struct {
	Name      *string `json:"name,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
}

// ServiceOverview defines model for ServiceOverview.
type ServiceOverview struct {
	AdditionalDetailSample *AdditionalItem `json:"additionalDetailSample,omitempty"`

	// Has label app
	AppLabel bool `json:"appLabel"`

	// Define if Pods related to this Service has an IstioSidecar deployed
	IstioSidecar bool `json:"istioSidecar"`

	// Labels for Service
	Labels *ServiceOverview_Labels `json:"labels,omitempty"`

	// Name of the Service
	Name string `json:"name"`
}

// ServiceOverview_Labels defines model for ServiceOverview.Labels.
type ServiceOverview_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ServiceRole defines model for ServiceRole.
type ServiceRole struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		Rules *map[string]interface{} `json:"rules,omitempty"`
	} `json:"spec,omitempty"`
}

// ServiceRoleBinding defines model for ServiceRoleBinding.
type ServiceRoleBinding struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		RoleRef  *map[string]interface{} `json:"roleRef,omitempty"`
		Subjects *map[string]interface{} `json:"subjects,omitempty"`
	} `json:"spec,omitempty"`
}

// ServiceRoleBindings defines model for ServiceRoleBindings.
type ServiceRoleBindings []ServiceRoleBinding

// ServiceRoles defines model for ServiceRoles.
type ServiceRoles []ServiceRole

// Services defines model for Services.
type Services []Service

// SeverityLevel defines model for SeverityLevel.
type SeverityLevel string

// Sidecar defines model for Sidecar.
type Sidecar struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		Egress           *map[string]interface{} `json:"egress,omitempty"`
		Ingress          *map[string]interface{} `json:"ingress,omitempty"`
		WorkloadSelector *map[string]interface{} `json:"workloadSelector,omitempty"`
	} `json:"spec,omitempty"`
}

// Sidecars defines model for Sidecars.
type Sidecars []Sidecar

// Span defines model for Span.
type Span struct {
	Duration      *int    `json:"duration,omitempty"`
	Flags         *int    `json:"flags,omitempty"`
	Logs          *[]Log  `json:"logs,omitempty"`
	OperationName *string `json:"operationName,omitempty"`

	// SpanID is the id of a span
	ParentSpanID *SpanID `json:"parentSpanID,omitempty"`

	// Process is the process emitting a set of spans
	Process    *Process     `json:"process,omitempty"`
	ProcessID  *ProcessID   `json:"processID,omitempty"`
	References *[]Reference `json:"references,omitempty"`

	// SpanID is the id of a span
	SpanID    *SpanID     `json:"spanID,omitempty"`
	StartTime *int        `json:"startTime,omitempty"`
	Tags      *[]KeyValue `json:"tags,omitempty"`
	TraceID   *TraceID    `json:"traceID,omitempty"`
	TraceSize *int64      `json:"traceSize,omitempty"`
	Warnings  *[]string   `json:"warnings,omitempty"`
}

// SpanID defines model for SpanID.
type SpanID string

// Status defines model for Status.
type Status struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Suggested HTTP return code for this status, 0 if not set.
	// +optional
	Code *int32 `json:"code,omitempty"`

	// continue may be set if the user set a limit on the number of items returned, and indicates that
	// the server has more data available. The value is opaque and may be used to issue another request
	// to the endpoint that served this list to retrieve the next set of available objects. Continuing a
	// consistent list may not be possible if the server configuration has changed or more than a few
	// minutes have passed. The resourceVersion field returned when using this continue value will be
	// identical to the value in the first response, unless you have received this token from an error
	// message.
	Continue *string `json:"continue,omitempty"`

	// StatusDetails is a set of additional properties that MAY be set by the
	// server to provide additional information about a response. The Reason
	// field of a Status object defines what attributes will be set. Clients
	// must ignore fields that do not match the defined type of each attribute,
	// and should assume that any attribute may be empty, invalid, or under
	// defined.
	Details *StatusDetails `json:"details,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// A human-readable description of the status of this operation.
	// +optional
	Message *string `json:"message,omitempty"`

	// StatusReason is an enumeration of possible failure causes.  Each StatusReason
	// must map to a single HTTP status code, but multiple reasons may map
	// to the same HTTP status code.
	// TODO: move to apiserver
	Reason *StatusReason `json:"reason,omitempty"`

	// String that identifies the server's internal version of this object that
	// can be used by clients to determine when objects have changed.
	// Value must be treated as opaque by clients and passed unmodified back to the server.
	// Populated by the system.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	// +optional
	ResourceVersion *string `json:"resourceVersion,omitempty"`

	// selfLink is a URL representing this object.
	// Populated by the system.
	// Read-only.
	// +optional
	SelfLink *string `json:"selfLink,omitempty"`

	// Status of the operation.
	// One of: "Success" or "Failure".
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
	// +optional
	Status *string `json:"status,omitempty"`
}

// StatusCause defines model for StatusCause.
type StatusCause struct {

	// The field of the resource that has caused this error, as named by its JSON
	// serialization. May include dot and postfix notation for nested attributes.
	// Arrays are zero-indexed.  Fields may appear more than once in an array of
	// causes due to fields having multiple errors.
	// Optional.
	//
	// Examples:
	// "name" - the field "name" on the current resource
	// "items[0].name" - the field "name" on the first array entry in "items"
	// +optional
	Field *string `json:"field,omitempty"`

	// A human-readable description of the cause of the error.  This field may be
	// presented as-is to a reader.
	// +optional
	Message *string `json:"message,omitempty"`

	// CauseType is a machine readable value providing more detail about what
	// occurred in a status response. An operation may have multiple causes for a
	// status (whether Failure or Success).
	Reason *CauseType `json:"reason,omitempty"`
}

// StatusDetails defines model for StatusDetails.
type StatusDetails struct {

	// The Causes array includes more details associated with the StatusReason
	// failure. Not all StatusReasons may provide detailed causes.
	// +optional
	Causes *[]StatusCause `json:"causes,omitempty"`

	// The group attribute of the resource associated with the status StatusReason.
	// +optional
	Group *string `json:"group,omitempty"`

	// The kind attribute of the resource associated with the status StatusReason.
	// On some operations may differ from the requested resource Kind.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// The name attribute of the resource associated with the status StatusReason
	// (when there is a single name which can be described).
	// +optional
	Name *string `json:"name,omitempty"`

	// If specified, the time in seconds before the operation should be retried. Some errors may indicate
	// the client must take an alternate action - for those errors this field may indicate how long to wait
	// before taking the alternate action.
	// +optional
	RetryAfterSeconds *int32 `json:"retryAfterSeconds,omitempty"`

	// UID is a type that holds unique ID values, including UUIDs.  Because we
	// don't ONLY use UUIDs, this is an alias to string.  Being a type captures
	// intent and helps make sure that UIDs and names do not get conflated.
	Uid *UID `json:"uid,omitempty"`
}

// StatusInfo defines model for StatusInfo.
type StatusInfo struct {

	// An array of external services installed
	ExternalServices []ExternalServiceInfo `json:"externalServices"`

	// The state of Kiali
	// A hash of key,values with versions of Kiali and state
	Status StatusInfo_Status `json:"status"`

	// An array of warningMessages
	WarningMessages *[]string `json:"warningMessages,omitempty"`
}

// StatusInfo_Status defines model for StatusInfo.Status.
type StatusInfo_Status struct {
	AdditionalProperties map[string]string `json:"-"`
}

// StatusReason defines model for StatusReason.
type StatusReason string

// ThreeScaleHandler defines model for ThreeScaleHandler.
type ThreeScaleHandler struct {
	AccessToken *string `json:"accessToken,omitempty"`
	Name        *string `json:"name,omitempty"`
	ServiceId   *string `json:"serviceId,omitempty"`
	SystemUrl   *string `json:"systemUrl,omitempty"`
}

// ThreeScaleHandlers defines model for ThreeScaleHandlers.
type ThreeScaleHandlers []ThreeScaleHandler

// ThreeScaleInfo defines model for ThreeScaleInfo.
type ThreeScaleInfo struct {
	Enabled *bool `json:"enabled,omitempty"`

	// ResourcePermissions holds permission flags for an object type
	// True means allowed.
	Permissions *ResourcePermissions `json:"permissions,omitempty"`
}

// ThreeScaleServiceRule defines model for ThreeScaleServiceRule.
type ThreeScaleServiceRule struct {
	ServiceName           *string `json:"serviceName,omitempty"`
	ServiceNamespace      *string `json:"serviceNamespace,omitempty"`
	ThreeScaleHandlerName *string `json:"threeScaleHandlerName,omitempty"`
}

// Time defines model for Time.
type Time map[string]interface{}

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {

	// The expired time for the token
	// A string with the Datetime when the token will be expired
	ExpiresOn string `json:"expiresOn"`

	// The authentication token
	// A string with the authentication token for the user
	Token string `json:"token"`

	// The username for the token
	// A string with the user's username
	Username string `json:"username"`
}

// Trace defines model for Trace.
type Trace struct {
	Processes *Trace_Processes `json:"processes,omitempty"`
	Spans     *[]Span          `json:"spans,omitempty"`
	TraceID   *TraceID         `json:"traceID,omitempty"`
	Warnings  *[]string        `json:"warnings,omitempty"`
}

// Trace_Processes defines model for Trace.Processes.
type Trace_Processes struct {
	AdditionalProperties map[string]Process `json:"-"`
}

// TraceID defines model for TraceID.
type TraceID string

// UID defines model for UID.
type UID string

// ValueType defines model for ValueType.
type ValueType string

// Workload defines model for Workload.
type Workload struct {
	AdditionalDetailSample *AdditionalItem `json:"additionalDetailSample,omitempty"`

	// Additional details to display, such as configured annotations
	AdditionalDetails *[]AdditionalItem `json:"additionalDetails,omitempty"`

	// Define if Pods related to this Workload has the label App
	AppLabel bool `json:"appLabel"`

	// Number of available replicas
	AvailableReplicas int32 `json:"availableReplicas"`

	// Creation timestamp (in RFC3339 format)
	CreatedAt string `json:"createdAt"`

	// Number of current replicas pods that matches controller selector labels
	CurrentReplicas int32 `json:"currentReplicas"`

	// Number of desired replicas defined by the user in the controller Spec
	DesiredReplicas int32 `json:"desiredReplicas"`

	// Define if Pods related to this Workload has an IstioSidecar deployed
	IstioSidecar bool `json:"istioSidecar"`

	// Workload labels
	Labels *Workload_Labels `json:"labels,omitempty"`

	// Name of the workload
	Name string `json:"name"`

	// Number of current workload pods
	PodCount int64 `json:"podCount"`

	// Pods alias for list of Pod structs
	Pods *Pods `json:"pods,omitempty"`

	// Kubernetes ResourceVersion
	ResourceVersion string `json:"resourceVersion"`

	// Runtimes and associated dashboards
	Runtimes *[]Runtime `json:"runtimes,omitempty"`
	Services *Services  `json:"services,omitempty"`

	// Type of the workload
	Type string `json:"type"`

	// Define if Pods related to this Workload has the label Version
	VersionLabel bool `json:"versionLabel"`
}

// Workload_Labels defines model for Workload.Labels.
type Workload_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// WorkloadHealth defines model for WorkloadHealth.
type WorkloadHealth struct {

	// RequestHealth holds several stats about recent request errors
	Requests *RequestHealth `json:"requests,omitempty"`

	// WorkloadStatus gives
	// number of desired replicas defined in the Spec of a controller
	// number of current replicas that matches selector of a controller
	// number of available replicas for a given workload
	// In healthy scenarios all variables should point same value.
	// When something wrong happens the different values can indicate an unhealthy situation.
	// i.e.
	// desired = 1, current = 10, available = 0 would means that a user scaled down a workload from 10 to 1
	// but in the operaton 10 pods showed problems, so no pod is available/ready but user will see 10 pods under a workload
	WorkloadStatus *WorkloadStatus `json:"workloadStatus,omitempty"`
}

// WorkloadItem defines model for WorkloadItem.
type WorkloadItem struct {

	// Define if all Pods related to the Workload has an IstioSidecar deployed
	IstioSidecar bool `json:"istioSidecar"`

	// Name of a workload member of an application
	WorkloadName string `json:"workloadName"`
}

// WorkloadList defines model for WorkloadList.
type WorkloadList struct {

	// A Namespace provide a scope for names
	// This type is used to describe a set of objects.
	Namespace Namespace `json:"namespace"`

	// Workloads for a given namespace
	Workloads []WorkloadListItem `json:"workloads"`
}

// WorkloadListItem defines model for WorkloadListItem.
type WorkloadListItem struct {
	AdditionalDetailSample *AdditionalItem `json:"additionalDetailSample,omitempty"`

	// Define if Pods related to this Workload has the label App
	AppLabel bool `json:"appLabel"`

	// Creation timestamp (in RFC3339 format)
	CreatedAt string `json:"createdAt"`

	// Define if Pods related to this Workload has an IstioSidecar deployed
	IstioSidecar bool `json:"istioSidecar"`

	// Workload labels
	Labels *WorkloadListItem_Labels `json:"labels,omitempty"`

	// Name of the workload
	Name string `json:"name"`

	// Number of current workload pods
	PodCount int64 `json:"podCount"`

	// Kubernetes ResourceVersion
	ResourceVersion string `json:"resourceVersion"`

	// Type of the workload
	Type string `json:"type"`

	// Define if Pods related to this Workload has the label Version
	VersionLabel bool `json:"versionLabel"`
}

// WorkloadListItem_Labels defines model for WorkloadListItem.Labels.
type WorkloadListItem_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// WorkloadOverviews defines model for WorkloadOverviews.
type WorkloadOverviews []WorkloadListItem

// WorkloadStatus defines model for WorkloadStatus.
type WorkloadStatus struct {
	AvailableReplicas *int32  `json:"availableReplicas,omitempty"`
	CurrentReplicas   *int32  `json:"currentReplicas,omitempty"`
	DesiredReplicas   *int32  `json:"desiredReplicas,omitempty"`
	Name              *string `json:"name,omitempty"`
}

// AuthorizationPolicy defines model for authorizationPolicy.
type AuthorizationPolicy struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		Rules    *map[string]interface{} `json:"rules,omitempty"`
		Selector *map[string]interface{} `json:"selector,omitempty"`
	} `json:"spec,omitempty"`
}

// AuthorizationRules defines model for authorizationRules.
type AuthorizationRules []AuthorizationPolicy

// DestinationRule defines model for destinationRule.
type DestinationRule struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		Host          *map[string]interface{} `json:"host,omitempty"`
		Subsets       *map[string]interface{} `json:"subsets,omitempty"`
		TrafficPolicy *map[string]interface{} `json:"trafficPolicy,omitempty"`
	} `json:"spec,omitempty"`
}

// DestinationRules defines model for destinationRules.
type DestinationRules struct {
	Items *[]DestinationRule `json:"items,omitempty"`

	// ResourcePermissions holds permission flags for an object type
	// True means allowed.
	Permissions *ResourcePermissions `json:"permissions,omitempty"`
}

// ExternalServiceInfo defines model for externalServiceInfo.
type ExternalServiceInfo struct {

	// The name of the service
	Name string `json:"name"`

	// The service url
	Url *string `json:"url,omitempty"`

	// The installed version of the service
	Version *string `json:"version,omitempty"`
}

// IstioAdapter defines model for istioAdapter.
type IstioAdapter struct {
	Adapter *string `json:"adapter,omitempty"`

	// We need to bring the plural to use it from the UI to build the API
	Adapters *string `json:"adapters,omitempty"`

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta             `json:"metadata,omitempty"`
	Spec     *map[string]interface{} `json:"spec,omitempty"`
}

// IstioAdapters defines model for istioAdapters.
type IstioAdapters []IstioAdapter

// IstioRule defines model for istioRule.
type IstioRule struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		Actions *map[string]interface{} `json:"actions,omitempty"`
		Match   *map[string]interface{} `json:"match,omitempty"`
	} `json:"spec,omitempty"`
}

// IstioRules defines model for istioRules.
type IstioRules []IstioRule

// IstioTemplate defines model for istioTemplate.
type IstioTemplate struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta             `json:"metadata,omitempty"`
	Spec     *map[string]interface{} `json:"spec,omitempty"`
	Template *string                 `json:"template,omitempty"`

	// We need to bring the plural to use it from the UI to build the API
	Templates *string `json:"templates,omitempty"`
}

// IstioTemplates defines model for istioTemplates.
type IstioTemplates []IstioTemplate

// Namespace defines model for namespace.
type Namespace struct {

	// Labels for Namespace
	Labels *Namespace_Labels `json:"labels,omitempty"`

	// The id of the namespace.
	Name string `json:"name"`
}

// Namespace_Labels defines model for Namespace.Labels.
type Namespace_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// VirtualService defines model for virtualService.
type VirtualService struct {

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
	// +optional
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	Kind *string `json:"kind,omitempty"`

	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
	// users must create.
	Metadata *ObjectMeta `json:"metadata,omitempty"`
	Spec     *struct {
		ExportTo *map[string]interface{} `json:"exportTo,omitempty"`
		Gateways *map[string]interface{} `json:"gateways,omitempty"`
		Hosts    *map[string]interface{} `json:"hosts,omitempty"`
		Http     *map[string]interface{} `json:"http,omitempty"`
		Tcp      *map[string]interface{} `json:"tcp,omitempty"`
		Tls      *map[string]interface{} `json:"tls,omitempty"`
	} `json:"spec,omitempty"`
}

// VirtualServices defines model for virtualServices.
type VirtualServices struct {
	Items *[]VirtualService `json:"items,omitempty"`

	// ResourcePermissions holds permission flags for an object type
	// True means allowed.
	Permissions *ResourcePermissions `json:"permissions,omitempty"`
}

// AppDetails defines model for appDetails.
type AppDetails App

// AppHealthResponse defines model for appHealthResponse.
type AppHealthResponse AppHealth

// AppListResponse defines model for appListResponse.
type AppListResponse AppList

// BadRequestError defines model for badRequestError.
type BadRequestError struct {

	// HTTP status code
	Code    *int32  `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// DashboardResponse defines model for dashboardResponse.
type DashboardResponse MonitoringDashboard

// GrafanaInfoResponse defines model for grafanaInfoResponse.
type GrafanaInfoResponse GrafanaInfo

// GraphResponse defines model for graphResponse.
type GraphResponse Config

// InternalError defines model for internalError.
type InternalError struct {

	// HTTP status code
	Code    *int32  `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// IstioConfigDetailsResponse defines model for istioConfigDetailsResponse.
type IstioConfigDetailsResponse IstioConfigDetails

// Iter8ExperimentGetDetailResponse defines model for iter8ExperimentGetDetailResponse.
type Iter8ExperimentGetDetailResponse Iter8ExperimentDetail

// Iter8ExperimentsGetResponse defines model for iter8ExperimentsGetResponse.
type Iter8ExperimentsGetResponse []Iter8ExperimentItem

// Iter8StatusResponse defines model for iter8StatusResponse.
type Iter8StatusResponse Iter8Info

// JaegerInfoResponse defines model for jaegerInfoResponse.
type JaegerInfoResponse JaegerInfo

// MeshTlsResponse defines model for meshTlsResponse.
type MeshTlsResponse MTLSStatus

// MetricsResponse defines model for metricsResponse.
type MetricsResponse Metrics

// NamespaceAppHealthResponse defines model for namespaceAppHealthResponse.
type NamespaceAppHealthResponse NamespaceAppHealth

// NamespaceList defines model for namespaceList.
type NamespaceList []Namespace

// NamespaceTlsResponse defines model for namespaceTlsResponse.
type NamespaceTlsResponse MTLSStatus

// NamespaceValidationSummaryResponse defines model for namespaceValidationSummaryResponse.
type NamespaceValidationSummaryResponse IstioValidationSummary

// NoContent defines model for noContent.
type NoContent struct {

	// HTTP status code
	Code    *int32  `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// NotAcceptableError defines model for notAcceptableError.
type NotAcceptableError struct {

	// HTTP status code
	Code    *int32  `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// NotFoundError defines model for notFoundError.
type NotFoundError struct {

	// HTTP status code
	Code    *int32  `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// ServiceDetailsResponse defines model for serviceDetailsResponse.
type ServiceDetailsResponse ServiceDetails

// ServiceHealthResponse defines model for serviceHealthResponse.
type ServiceHealthResponse ServiceHealth

// ServiceListResponse defines model for serviceListResponse.
type ServiceListResponse ServiceList

// ServiceUnavailableError defines model for serviceUnavailableError.
type ServiceUnavailableError struct {

	// HTTP status code
	Code    *int32  `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// SpansResponse defines model for spansResponse.
type SpansResponse []Span

// ThreeScaleHandlersResponse defines model for threeScaleHandlersResponse.
type ThreeScaleHandlersResponse ThreeScaleHandlers

// ThreeScaleInfoResponse defines model for threeScaleInfoResponse.
type ThreeScaleInfoResponse ThreeScaleInfo

// ThreeScaleRuleResponse defines model for threeScaleRuleResponse.
type ThreeScaleRuleResponse ThreeScaleServiceRule

// TracesDetailResponse defines model for tracesDetailResponse.
type TracesDetailResponse []Trace

// WorkloadDetails defines model for workloadDetails.
type WorkloadDetails Workload

// WorkloadHealthResponse defines model for workloadHealthResponse.
type WorkloadHealthResponse WorkloadHealth

// WorkloadListResponse defines model for workloadListResponse.
type WorkloadListResponse WorkloadList

// GraphNamespacesParams defines parameters for GraphNamespaces.
type GraphNamespacesParams struct {

	// Comma-separated list of Appenders to run. Available appenders: [deadNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, unusedNode].
	Appenders *string `json:"appenders,omitempty"`

	// Query time-range duration (Golang string duration).
	Duration *string `json:"duration,omitempty"`

	// Graph type. Available graph types: [app, service, versionedApp, workload].
	GraphType *string `json:"graphType,omitempty"`

	// App box grouping characteristic. Available groupings: [app, none, version].
	GroupBy *string `json:"groupBy,omitempty"`

	// Flag for injecting the requested service node between source and destination nodes.
	InjectServiceNodes *string `json:"injectServiceNodes,omitempty"`

	// Comma-separated list of namespaces to include in the graph. The namespaces must be accessible to the client.
	Namespaces string `json:"namespaces"`

	// Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
	QueryTime *string `json:"queryTime,omitempty"`
}

// GraphAppParams defines parameters for GraphApp.
type GraphAppParams struct {

	// Comma-separated list of Appenders to run. Available appenders: [deadNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, unusedNode].
	Appenders *string `json:"appenders,omitempty"`

	// Query time-range duration (Golang string duration).
	Duration *string `json:"duration,omitempty"`

	// Graph type. Available graph types: [app, service, versionedApp, workload].
	GraphType *string `json:"graphType,omitempty"`

	// App box grouping characteristic. Available groupings: [app, none, version].
	GroupBy *string `json:"groupBy,omitempty"`

	// Flag for injecting the requested service node between source and destination nodes.
	InjectServiceNodes *string `json:"injectServiceNodes,omitempty"`

	// Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
	QueryTime *string `json:"queryTime,omitempty"`
}

// GraphAppVersionParams defines parameters for GraphAppVersion.
type GraphAppVersionParams struct {

	// Comma-separated list of Appenders to run. Available appenders: [deadNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, unusedNode].
	Appenders *string `json:"appenders,omitempty"`

	// Query time-range duration (Golang string duration).
	Duration *string `json:"duration,omitempty"`

	// Graph type. Available graph types: [app, service, versionedApp, workload].
	GraphType *string `json:"graphType,omitempty"`

	// App box grouping characteristic. Available groupings: [app, none, version].
	GroupBy *string `json:"groupBy,omitempty"`

	// Flag for injecting the requested service node between source and destination nodes.
	InjectServiceNodes *string `json:"injectServiceNodes,omitempty"`

	// Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
	QueryTime *string `json:"queryTime,omitempty"`
}

// AppDashboardParams defines parameters for AppDashboard.
type AppDashboardParams struct {

	// Flag for fetching histogram average. Default is true.
	Avg *bool `json:"avg,omitempty"`

	// List of labels to use for grouping metrics (via Prometheus 'by' clause).
	ByLabels *[]string `json:"byLabels[],omitempty"`

	// Traffic direction: 'inbound' or 'outbound'.
	Direction *string `json:"direction,omitempty"`

	// Duration of the query period, in seconds.
	Duration *int64 `json:"duration,omitempty"`

	// List of quantiles to fetch. Fetch no quantiles when empty. Ex: [0.5, 0.95, 0.99].
	Quantiles *[]string `json:"quantiles[],omitempty"`

	// Prometheus function used to calculate rate: 'rate' or 'irate'.
	RateFunc *string `json:"rateFunc,omitempty"`

	// Interval used for rate and histogram calculation.
	RateInterval *string `json:"rateInterval,omitempty"`

	// Desired request protocol for the telemetry: For example, 'http' or 'grpc'.
	RequestProtocol *string `json:"requestProtocol,omitempty"`

	// Istio telemetry reporter: 'source' or 'destination'.
	Reporter *string `json:"reporter,omitempty"`

	// Step between [graph] datapoints, in seconds.
	Step *int64 `json:"step,omitempty"`
}

// AppHealthParams defines parameters for AppHealth.
type AppHealthParams struct {

	// The rate interval used for fetching error rate
	RateInterval *string `json:"rateInterval,omitempty"`

	// The time to use for the prometheus query
	QueryTime *time.Time `json:"QueryTime,omitempty"`
}

// AppMetricsParams defines parameters for AppMetrics.
type AppMetricsParams struct {

	// Flag for fetching histogram average. Default is true.
	Avg *bool `json:"avg,omitempty"`

	// List of labels to use for grouping metrics (via Prometheus 'by' clause).
	ByLabels *[]string `json:"byLabels[],omitempty"`

	// Traffic direction: 'inbound' or 'outbound'.
	Direction *string `json:"direction,omitempty"`

	// Duration of the query period, in seconds.
	Duration *int64 `json:"duration,omitempty"`

	// List of metrics to fetch. Fetch all metrics when empty. List entries are Kiali internal metric names.
	Filters *[]string `json:"filters[],omitempty"`

	// List of quantiles to fetch. Fetch no quantiles when empty. Ex: [0.5, 0.95, 0.99].
	Quantiles *[]string `json:"quantiles[],omitempty"`

	// Prometheus function used to calculate rate: 'rate' or 'irate'.
	RateFunc *string `json:"rateFunc,omitempty"`

	// Interval used for rate and histogram calculation.
	RateInterval *string `json:"rateInterval,omitempty"`

	// Desired request protocol for the telemetry: For example, 'http' or 'grpc'.
	RequestProtocol *string `json:"requestProtocol,omitempty"`

	// Istio telemetry reporter: 'source' or 'destination'.
	Reporter *string `json:"reporter,omitempty"`

	// Step between [graph] datapoints, in seconds.
	Step *int64 `json:"step,omitempty"`

	// Filters metrics by the specified version.
	Version *string `json:"version,omitempty"`
}

// CustomDashboardParams defines parameters for CustomDashboard.
type CustomDashboardParams struct {

	// In custom dashboards, additional labels that are made available for grouping in the UI, regardless which aggregations are defined in the MonitoringDashboard CR
	AdditionalLabels *string `json:"additionalLabels,omitempty"`

	// Flag for fetching histogram average. Default is true.
	Avg *bool `json:"avg,omitempty"`

	// List of labels to use for grouping metrics (via Prometheus 'by' clause).
	ByLabels *[]string `json:"byLabels[],omitempty"`

	// Duration of the query period, in seconds.
	Duration *int64 `json:"duration,omitempty"`

	// In custom dashboards, labels filters to use when fetching metrics, formatted as key:value pairs. Ex: "app:foo,version:bar".
	LabelsFilters *string `json:"labelsFilters,omitempty"`

	// List of quantiles to fetch. Fetch no quantiles when empty. Ex: [0.5, 0.95, 0.99].
	Quantiles *[]string `json:"quantiles[],omitempty"`

	// Prometheus function used to calculate rate: 'rate' or 'irate'.
	RateFunc *string `json:"rateFunc,omitempty"`

	// Interval used for rate and histogram calculation.
	RateInterval *string `json:"rateInterval,omitempty"`

	// Step between [graph] datapoints, in seconds.
	Step *int64 `json:"step,omitempty"`
}

// NamespaceHealthParams defines parameters for NamespaceHealth.
type NamespaceHealthParams struct {

	// The rate interval used for fetching error rate
	RateInterval *string `json:"rateInterval,omitempty"`

	// The time to use for the prometheus query
	QueryTime *time.Time `json:"QueryTime,omitempty"`

	// The type of health, "app", "service" or "workload".
	Type *string `json:"type,omitempty"`
}

// PodLogsParams defines parameters for PodLogs.
type PodLogsParams struct {

	// The pod container name. Optional for single-container pod. Otherwise required.
	Container *string `json:"container,omitempty"`

	// The start time for fetching logs. UNIX time in seconds. Default is all logs.
	SinceTime *string `json:"sinceTime,omitempty"`
}

// ServiceDashboardParams defines parameters for ServiceDashboard.
type ServiceDashboardParams struct {

	// Flag for fetching histogram average. Default is true.
	Avg *bool `json:"avg,omitempty"`

	// List of labels to use for grouping metrics (via Prometheus 'by' clause).
	ByLabels *[]string `json:"byLabels[],omitempty"`

	// Traffic direction: 'inbound' or 'outbound'.
	Direction *string `json:"direction,omitempty"`

	// Duration of the query period, in seconds.
	Duration *int64 `json:"duration,omitempty"`

	// List of quantiles to fetch. Fetch no quantiles when empty. Ex: [0.5, 0.95, 0.99].
	Quantiles *[]string `json:"quantiles[],omitempty"`

	// Prometheus function used to calculate rate: 'rate' or 'irate'.
	RateFunc *string `json:"rateFunc,omitempty"`

	// Interval used for rate and histogram calculation.
	RateInterval *string `json:"rateInterval,omitempty"`

	// Desired request protocol for the telemetry: For example, 'http' or 'grpc'.
	RequestProtocol *string `json:"requestProtocol,omitempty"`

	// Istio telemetry reporter: 'source' or 'destination'.
	Reporter *string `json:"reporter,omitempty"`

	// Step between [graph] datapoints, in seconds.
	Step *int64 `json:"step,omitempty"`
}

// GraphServiceParams defines parameters for GraphService.
type GraphServiceParams struct {

	// Comma-separated list of Appenders to run. Available appenders: [deadNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, unusedNode].
	Appenders *string `json:"appenders,omitempty"`

	// Query time-range duration (Golang string duration).
	Duration *string `json:"duration,omitempty"`

	// Graph type. Available graph types: [app, service, versionedApp, workload].
	GraphType *string `json:"graphType,omitempty"`

	// App box grouping characteristic. Available groupings: [app, none, version].
	GroupBy *string `json:"groupBy,omitempty"`

	// Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
	QueryTime *string `json:"queryTime,omitempty"`
}

// ServiceHealthParams defines parameters for ServiceHealth.
type ServiceHealthParams struct {

	// The rate interval used for fetching error rate
	RateInterval *string `json:"rateInterval,omitempty"`

	// The time to use for the prometheus query
	QueryTime *time.Time `json:"QueryTime,omitempty"`
}

// ServiceMetricsParams defines parameters for ServiceMetrics.
type ServiceMetricsParams struct {

	// Flag for fetching histogram average. Default is true.
	Avg *bool `json:"avg,omitempty"`

	// List of labels to use for grouping metrics (via Prometheus 'by' clause).
	ByLabels *[]string `json:"byLabels[],omitempty"`

	// Traffic direction: 'inbound' or 'outbound'.
	Direction *string `json:"direction,omitempty"`

	// Duration of the query period, in seconds.
	Duration *int64 `json:"duration,omitempty"`

	// List of metrics to fetch. Fetch all metrics when empty. List entries are Kiali internal metric names.
	Filters *[]string `json:"filters[],omitempty"`

	// List of quantiles to fetch. Fetch no quantiles when empty. Ex: [0.5, 0.95, 0.99].
	Quantiles *[]string `json:"quantiles[],omitempty"`

	// Prometheus function used to calculate rate: 'rate' or 'irate'.
	RateFunc *string `json:"rateFunc,omitempty"`

	// Interval used for rate and histogram calculation.
	RateInterval *string `json:"rateInterval,omitempty"`

	// Desired request protocol for the telemetry: For example, 'http' or 'grpc'.
	RequestProtocol *string `json:"requestProtocol,omitempty"`

	// Istio telemetry reporter: 'source' or 'destination'.
	Reporter *string `json:"reporter,omitempty"`

	// Step between [graph] datapoints, in seconds.
	Step *int64 `json:"step,omitempty"`

	// Filters metrics by the specified version.
	Version *string `json:"version,omitempty"`
}

// WorkloadDashboardParams defines parameters for WorkloadDashboard.
type WorkloadDashboardParams struct {

	// Flag for fetching histogram average. Default is true.
	Avg *bool `json:"avg,omitempty"`

	// List of labels to use for grouping metrics (via Prometheus 'by' clause).
	ByLabels *[]string `json:"byLabels[],omitempty"`

	// Traffic direction: 'inbound' or 'outbound'.
	Direction *string `json:"direction,omitempty"`

	// Duration of the query period, in seconds.
	Duration *int64 `json:"duration,omitempty"`

	// List of quantiles to fetch. Fetch no quantiles when empty. Ex: [0.5, 0.95, 0.99].
	Quantiles *[]string `json:"quantiles[],omitempty"`

	// Prometheus function used to calculate rate: 'rate' or 'irate'.
	RateFunc *string `json:"rateFunc,omitempty"`

	// Interval used for rate and histogram calculation.
	RateInterval *string `json:"rateInterval,omitempty"`

	// Desired request protocol for the telemetry: For example, 'http' or 'grpc'.
	RequestProtocol *string `json:"requestProtocol,omitempty"`

	// Istio telemetry reporter: 'source' or 'destination'.
	Reporter *string `json:"reporter,omitempty"`

	// Step between [graph] datapoints, in seconds.
	Step *int64 `json:"step,omitempty"`
}

// GraphWorkloadParams defines parameters for GraphWorkload.
type GraphWorkloadParams struct {

	// Comma-separated list of Appenders to run. Available appenders: [deadNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, unusedNode].
	Appenders *string `json:"appenders,omitempty"`

	// Query time-range duration (Golang string duration).
	Duration *string `json:"duration,omitempty"`

	// Graph type. Available graph types: [app, service, versionedApp, workload].
	GraphType *string `json:"graphType,omitempty"`

	// App box grouping characteristic. Available groupings: [app, none, version].
	GroupBy *string `json:"groupBy,omitempty"`

	// Flag for injecting the requested service node between source and destination nodes.
	InjectServiceNodes *string `json:"injectServiceNodes,omitempty"`

	// Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
	QueryTime *string `json:"queryTime,omitempty"`
}

// WorkloadHealthParams defines parameters for WorkloadHealth.
type WorkloadHealthParams struct {

	// The rate interval used for fetching error rate
	RateInterval *string `json:"rateInterval,omitempty"`

	// The time to use for the prometheus query
	QueryTime *time.Time `json:"QueryTime,omitempty"`
}

// WorkloadMetricsParams defines parameters for WorkloadMetrics.
type WorkloadMetricsParams struct {

	// Flag for fetching histogram average. Default is true.
	Avg *bool `json:"avg,omitempty"`

	// List of labels to use for grouping metrics (via Prometheus 'by' clause).
	ByLabels *[]string `json:"byLabels[],omitempty"`

	// Traffic direction: 'inbound' or 'outbound'.
	Direction *string `json:"direction,omitempty"`

	// Duration of the query period, in seconds.
	Duration *int64 `json:"duration,omitempty"`

	// List of metrics to fetch. Fetch all metrics when empty. List entries are Kiali internal metric names.
	Filters *[]string `json:"filters[],omitempty"`

	// List of quantiles to fetch. Fetch no quantiles when empty. Ex: [0.5, 0.95, 0.99].
	Quantiles *[]string `json:"quantiles[],omitempty"`

	// Prometheus function used to calculate rate: 'rate' or 'irate'.
	RateFunc *string `json:"rateFunc,omitempty"`

	// Interval used for rate and histogram calculation.
	RateInterval *string `json:"rateInterval,omitempty"`

	// Desired request protocol for the telemetry: For example, 'http' or 'grpc'.
	RequestProtocol *string `json:"requestProtocol,omitempty"`

	// Istio telemetry reporter: 'source' or 'destination'.
	Reporter *string `json:"reporter,omitempty"`

	// Step between [graph] datapoints, in seconds.
	Step *int64 `json:"step,omitempty"`

	// Filters metrics by the specified version.
	Version *string `json:"version,omitempty"`
}

// Getter for additional properties for AppListItem_Labels. Returns the specified
// element and whether it was found
func (a AppListItem_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AppListItem_Labels
func (a *AppListItem_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AppListItem_Labels to handle AdditionalProperties
func (a *AppListItem_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AppListItem_Labels to handle AdditionalProperties
func (a AppListItem_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Chart_Histogram. Returns the specified
// element and whether it was found
func (a Chart_Histogram) Get(fieldName string) (value []SampleStream, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Chart_Histogram
func (a *Chart_Histogram) Set(fieldName string, value []SampleStream) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]SampleStream)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Chart_Histogram to handle AdditionalProperties
func (a *Chart_Histogram) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]SampleStream)
		for fieldName, fieldBuf := range object {
			var fieldVal []SampleStream
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Chart_Histogram to handle AdditionalProperties
func (a Chart_Histogram) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Fields_Map. Returns the specified
// element and whether it was found
func (a Fields_Map) Get(fieldName string) (value Fields, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Fields_Map
func (a *Fields_Map) Set(fieldName string, value Fields) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Fields)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Fields_Map to handle AdditionalProperties
func (a *Fields_Map) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Fields)
		for fieldName, fieldBuf := range object {
			var fieldVal Fields
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Fields_Map to handle AdditionalProperties
func (a Fields_Map) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IstioConfigPermissions. Returns the specified
// element and whether it was found
func (a IstioConfigPermissions) Get(fieldName string) (value ResourcesPermissions, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IstioConfigPermissions
func (a *IstioConfigPermissions) Set(fieldName string, value ResourcesPermissions) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ResourcesPermissions)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IstioConfigPermissions to handle AdditionalProperties
func (a *IstioConfigPermissions) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ResourcesPermissions)
		for fieldName, fieldBuf := range object {
			var fieldVal ResourcesPermissions
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IstioConfigPermissions to handle AdditionalProperties
func (a IstioConfigPermissions) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Metrics_Histograms. Returns the specified
// element and whether it was found
func (a Metrics_Histograms) Get(fieldName string) (value struct {
	AdditionalProperties map[string]Metric `json:"-"`
}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Metrics_Histograms
func (a *Metrics_Histograms) Set(fieldName string, value struct {
	AdditionalProperties map[string]Metric `json:"-"`
}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]struct {
			AdditionalProperties map[string]Metric `json:"-"`
		})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Metrics_Histograms to handle AdditionalProperties
func (a *Metrics_Histograms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]struct {
			AdditionalProperties map[string]Metric `json:"-"`
		})
		for fieldName, fieldBuf := range object {
			var fieldVal struct {
				AdditionalProperties map[string]Metric `json:"-"`
			}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Metrics_Histograms to handle AdditionalProperties
func (a Metrics_Histograms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Metrics_Metrics. Returns the specified
// element and whether it was found
func (a Metrics_Metrics) Get(fieldName string) (value Metric, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Metrics_Metrics
func (a *Metrics_Metrics) Set(fieldName string, value Metric) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Metric)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Metrics_Metrics to handle AdditionalProperties
func (a *Metrics_Metrics) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Metric)
		for fieldName, fieldBuf := range object {
			var fieldVal Metric
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Metrics_Metrics to handle AdditionalProperties
func (a Metrics_Metrics) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NamespaceAppHealth. Returns the specified
// element and whether it was found
func (a NamespaceAppHealth) Get(fieldName string) (value AppHealth, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NamespaceAppHealth
func (a *NamespaceAppHealth) Set(fieldName string, value AppHealth) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AppHealth)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NamespaceAppHealth to handle AdditionalProperties
func (a *NamespaceAppHealth) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AppHealth)
		for fieldName, fieldBuf := range object {
			var fieldVal AppHealth
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NamespaceAppHealth to handle AdditionalProperties
func (a NamespaceAppHealth) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ObjectMeta_Annotations. Returns the specified
// element and whether it was found
func (a ObjectMeta_Annotations) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ObjectMeta_Annotations
func (a *ObjectMeta_Annotations) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ObjectMeta_Annotations to handle AdditionalProperties
func (a *ObjectMeta_Annotations) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ObjectMeta_Annotations to handle AdditionalProperties
func (a ObjectMeta_Annotations) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ObjectMeta_Labels. Returns the specified
// element and whether it was found
func (a ObjectMeta_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ObjectMeta_Labels
func (a *ObjectMeta_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ObjectMeta_Labels to handle AdditionalProperties
func (a *ObjectMeta_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ObjectMeta_Labels to handle AdditionalProperties
func (a ObjectMeta_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Pod_Annotations. Returns the specified
// element and whether it was found
func (a Pod_Annotations) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Pod_Annotations
func (a *Pod_Annotations) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Pod_Annotations to handle AdditionalProperties
func (a *Pod_Annotations) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Pod_Annotations to handle AdditionalProperties
func (a Pod_Annotations) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Pod_Labels. Returns the specified
// element and whether it was found
func (a Pod_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Pod_Labels
func (a *Pod_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Pod_Labels to handle AdditionalProperties
func (a *Pod_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Pod_Labels to handle AdditionalProperties
func (a Pod_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProtocolTraffic_Rates. Returns the specified
// element and whether it was found
func (a ProtocolTraffic_Rates) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProtocolTraffic_Rates
func (a *ProtocolTraffic_Rates) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProtocolTraffic_Rates to handle AdditionalProperties
func (a *ProtocolTraffic_Rates) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProtocolTraffic_Rates to handle AdditionalProperties
func (a ProtocolTraffic_Rates) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ResourcesPermissions. Returns the specified
// element and whether it was found
func (a ResourcesPermissions) Get(fieldName string) (value ResourcePermissions, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ResourcesPermissions
func (a *ResourcesPermissions) Set(fieldName string, value ResourcePermissions) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ResourcePermissions)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ResourcesPermissions to handle AdditionalProperties
func (a *ResourcesPermissions) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ResourcePermissions)
		for fieldName, fieldBuf := range object {
			var fieldVal ResourcePermissions
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ResourcesPermissions to handle AdditionalProperties
func (a ResourcesPermissions) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ResponseFlags. Returns the specified
// element and whether it was found
func (a ResponseFlags) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ResponseFlags
func (a *ResponseFlags) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ResponseFlags to handle AdditionalProperties
func (a *ResponseFlags) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ResponseFlags to handle AdditionalProperties
func (a ResponseFlags) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ResponseHosts. Returns the specified
// element and whether it was found
func (a ResponseHosts) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ResponseHosts
func (a *ResponseHosts) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ResponseHosts to handle AdditionalProperties
func (a *ResponseHosts) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ResponseHosts to handle AdditionalProperties
func (a ResponseHosts) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Responses. Returns the specified
// element and whether it was found
func (a Responses) Get(fieldName string) (value ResponseDetail, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Responses
func (a *Responses) Set(fieldName string, value ResponseDetail) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ResponseDetail)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Responses to handle AdditionalProperties
func (a *Responses) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ResponseDetail)
		for fieldName, fieldBuf := range object {
			var fieldVal ResponseDetail
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Responses to handle AdditionalProperties
func (a Responses) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SampleStream_LabelSet. Returns the specified
// element and whether it was found
func (a SampleStream_LabelSet) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SampleStream_LabelSet
func (a *SampleStream_LabelSet) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SampleStream_LabelSet to handle AdditionalProperties
func (a *SampleStream_LabelSet) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SampleStream_LabelSet to handle AdditionalProperties
func (a SampleStream_LabelSet) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Service_Labels. Returns the specified
// element and whether it was found
func (a Service_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Service_Labels
func (a *Service_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Service_Labels to handle AdditionalProperties
func (a *Service_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Service_Labels to handle AdditionalProperties
func (a Service_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Service_Selectors. Returns the specified
// element and whether it was found
func (a Service_Selectors) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Service_Selectors
func (a *Service_Selectors) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Service_Selectors to handle AdditionalProperties
func (a *Service_Selectors) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Service_Selectors to handle AdditionalProperties
func (a Service_Selectors) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ServiceOverview_Labels. Returns the specified
// element and whether it was found
func (a ServiceOverview_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ServiceOverview_Labels
func (a *ServiceOverview_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ServiceOverview_Labels to handle AdditionalProperties
func (a *ServiceOverview_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ServiceOverview_Labels to handle AdditionalProperties
func (a ServiceOverview_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StatusInfo_Status. Returns the specified
// element and whether it was found
func (a StatusInfo_Status) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StatusInfo_Status
func (a *StatusInfo_Status) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StatusInfo_Status to handle AdditionalProperties
func (a *StatusInfo_Status) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StatusInfo_Status to handle AdditionalProperties
func (a StatusInfo_Status) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Trace_Processes. Returns the specified
// element and whether it was found
func (a Trace_Processes) Get(fieldName string) (value Process, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Trace_Processes
func (a *Trace_Processes) Set(fieldName string, value Process) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Process)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Trace_Processes to handle AdditionalProperties
func (a *Trace_Processes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Process)
		for fieldName, fieldBuf := range object {
			var fieldVal Process
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Trace_Processes to handle AdditionalProperties
func (a Trace_Processes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Workload_Labels. Returns the specified
// element and whether it was found
func (a Workload_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Workload_Labels
func (a *Workload_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Workload_Labels to handle AdditionalProperties
func (a *Workload_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Workload_Labels to handle AdditionalProperties
func (a Workload_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for WorkloadListItem_Labels. Returns the specified
// element and whether it was found
func (a WorkloadListItem_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for WorkloadListItem_Labels
func (a *WorkloadListItem_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for WorkloadListItem_Labels to handle AdditionalProperties
func (a *WorkloadListItem_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for WorkloadListItem_Labels to handle AdditionalProperties
func (a WorkloadListItem_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Namespace_Labels. Returns the specified
// element and whether it was found
func (a Namespace_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Namespace_Labels
func (a *Namespace_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Namespace_Labels to handle AdditionalProperties
func (a *Namespace_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Namespace_Labels to handle AdditionalProperties
func (a Namespace_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Root request
	Root(ctx context.Context) (*http.Response, error)

	// AuthenticationInfo request
	AuthenticationInfo(ctx context.Context) (*http.Response, error)

	// Authenticate request
	Authenticate(ctx context.Context) (*http.Response, error)

	// OpenshiftCheckToken request
	OpenshiftCheckToken(ctx context.Context) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context) (*http.Response, error)

	// GrafanaInfo request
	GrafanaInfo(ctx context.Context) (*http.Response, error)

	// GetPermissions request
	GetPermissions(ctx context.Context) (*http.Response, error)

	// DeleteIter8Experiments request
	DeleteIter8Experiments(ctx context.Context, namespace string, name string) (*http.Response, error)

	// PatchIter8Experiments request
	PatchIter8Experiments(ctx context.Context, namespace string, name string) (*http.Response, error)

	// PostIter8Experiments request
	PostIter8Experiments(ctx context.Context, namespace string) (*http.Response, error)

	// GetIter8Experiments request
	GetIter8Experiments(ctx context.Context, namespace string, name string) (*http.Response, error)

	// JaegerInfo request
	JaegerInfo(ctx context.Context) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context) (*http.Response, error)

	// MeshTls request
	MeshTls(ctx context.Context) (*http.Response, error)

	// NamespaceList request
	NamespaceList(ctx context.Context) (*http.Response, error)

	// GraphNamespaces request
	GraphNamespaces(ctx context.Context, params *GraphNamespacesParams) (*http.Response, error)

	// GraphApp request
	GraphApp(ctx context.Context, namespace string, app string, params *GraphAppParams) (*http.Response, error)

	// GraphAppVersion request
	GraphAppVersion(ctx context.Context, namespace string, app string, version string, params *GraphAppVersionParams) (*http.Response, error)

	// AppList request
	AppList(ctx context.Context, namespace string) (*http.Response, error)

	// AppDetails request
	AppDetails(ctx context.Context, namespace string, app string) (*http.Response, error)

	// AppDashboard request
	AppDashboard(ctx context.Context, namespace string, app string, params *AppDashboardParams) (*http.Response, error)

	// AppHealth request
	AppHealth(ctx context.Context, namespace string, app string, params *AppHealthParams) (*http.Response, error)

	// AppMetrics request
	AppMetrics(ctx context.Context, namespace string, app string, params *AppMetricsParams) (*http.Response, error)

	// CustomDashboard request
	CustomDashboard(ctx context.Context, namespace string, dashboard string, params *CustomDashboardParams) (*http.Response, error)

	// NamespaceHealth request
	NamespaceHealth(ctx context.Context, namespace string, params *NamespaceHealthParams) (*http.Response, error)

	// IstioConfigList request
	IstioConfigList(ctx context.Context, namespace string) (*http.Response, error)

	// IstioConfigCreate request
	IstioConfigCreate(ctx context.Context, namespace string, objectType string) (*http.Response, error)

	// IstioConfigCreateSubtype request
	IstioConfigCreateSubtype(ctx context.Context, namespace string, objectType string, objectSubtype string) (*http.Response, error)

	// IstioConfigDeleteSubtype request
	IstioConfigDeleteSubtype(ctx context.Context, namespace string, objectType string, objectSubtype string, object string) (*http.Response, error)

	// IstioConfigDetailsSubtype request
	IstioConfigDetailsSubtype(ctx context.Context, namespace string, objectType string, objectSubtype string, object string) (*http.Response, error)

	// IstioConfigUpdateSubtype request
	IstioConfigUpdateSubtype(ctx context.Context, namespace string, objectType string, objectSubtype string, object string) (*http.Response, error)

	// IstioConfigDelete request
	IstioConfigDelete(ctx context.Context, namespace string, objectType string, object string) (*http.Response, error)

	// IstioConfigDetails request
	IstioConfigDetails(ctx context.Context, namespace string, objectType string, object string) (*http.Response, error)

	// IstioConfigUpdate request
	IstioConfigUpdate(ctx context.Context, namespace string, objectType string, object string) (*http.Response, error)

	// NamespaceMetrics request
	NamespaceMetrics(ctx context.Context, namespace string) (*http.Response, error)

	// PodDetails request
	PodDetails(ctx context.Context, namespace string, pod string) (*http.Response, error)

	// PodLogs request
	PodLogs(ctx context.Context, namespace string, pod string, params *PodLogsParams) (*http.Response, error)

	// ServiceList request
	ServiceList(ctx context.Context, namespace string) (*http.Response, error)

	// ServiceDetails request
	ServiceDetails(ctx context.Context, namespace string, service string) (*http.Response, error)

	// ServiceDashboard request
	ServiceDashboard(ctx context.Context, namespace string, service string, params *ServiceDashboardParams) (*http.Response, error)

	// ErrorTraces request
	ErrorTraces(ctx context.Context, namespace string, service string) (*http.Response, error)

	// GraphService request
	GraphService(ctx context.Context, namespace string, service string, params *GraphServiceParams) (*http.Response, error)

	// ServiceHealth request
	ServiceHealth(ctx context.Context, namespace string, service string, params *ServiceHealthParams) (*http.Response, error)

	// ServiceMetrics request
	ServiceMetrics(ctx context.Context, namespace string, service string, params *ServiceMetricsParams) (*http.Response, error)

	// SpansList request
	SpansList(ctx context.Context, namespace string, service string) (*http.Response, error)

	// TracesDetail request
	TracesDetail(ctx context.Context, namespace string, service string) (*http.Response, error)

	// NamespaceTls request
	NamespaceTls(ctx context.Context, namespace string) (*http.Response, error)

	// NamespaceValidations request
	NamespaceValidations(ctx context.Context, namespace string) (*http.Response, error)

	// WorkloadList request
	WorkloadList(ctx context.Context, namespace string) (*http.Response, error)

	// WorkloadDetails request
	WorkloadDetails(ctx context.Context, namespace string, workload string) (*http.Response, error)

	// WorkloadDashboard request
	WorkloadDashboard(ctx context.Context, namespace string, workload string, params *WorkloadDashboardParams) (*http.Response, error)

	// GraphWorkload request
	GraphWorkload(ctx context.Context, namespace string, workload string, params *GraphWorkloadParams) (*http.Response, error)

	// WorkloadHealth request
	WorkloadHealth(ctx context.Context, namespace string, workload string, params *WorkloadHealthParams) (*http.Response, error)

	// WorkloadMetrics request
	WorkloadMetrics(ctx context.Context, namespace string, workload string, params *WorkloadMetricsParams) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context) (*http.Response, error)

	// GetThreeScaleInfo request
	GetThreeScaleInfo(ctx context.Context) (*http.Response, error)

	// GetThreeScaleHandlers request
	GetThreeScaleHandlers(ctx context.Context) (*http.Response, error)

	// PostThreeScaleHandlers request
	PostThreeScaleHandlers(ctx context.Context) (*http.Response, error)

	// DeleteThreeScaleHandler request
	DeleteThreeScaleHandler(ctx context.Context, threescaleHandlerName string) (*http.Response, error)

	// PatchThreeScaleHandler request
	PatchThreeScaleHandler(ctx context.Context, threescaleHandlerName string) (*http.Response, error)

	// PostThreeScaleService request
	PostThreeScaleService(ctx context.Context, namespace string) (*http.Response, error)

	// DeleteThreeScaleService request
	DeleteThreeScaleService(ctx context.Context, namespace string, service string) (*http.Response, error)

	// GetThreeScaleService request
	GetThreeScaleService(ctx context.Context, namespace string, service string) (*http.Response, error)

	// PatchThreeScaleService request
	PatchThreeScaleService(ctx context.Context, namespace string, service string) (*http.Response, error)
}

func (c *Client) Root(ctx context.Context) (*http.Response, error) {
	req, err := NewRootRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticationInfo(ctx context.Context) (*http.Response, error) {
	req, err := NewAuthenticationInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) Authenticate(ctx context.Context) (*http.Response, error) {
	req, err := NewAuthenticateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) OpenshiftCheckToken(ctx context.Context) (*http.Response, error) {
	req, err := NewOpenshiftCheckTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GrafanaInfo(ctx context.Context) (*http.Response, error) {
	req, err := NewGrafanaInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissions(ctx context.Context) (*http.Response, error) {
	req, err := NewGetPermissionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIter8Experiments(ctx context.Context, namespace string, name string) (*http.Response, error) {
	req, err := NewDeleteIter8ExperimentsRequest(c.Server, namespace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PatchIter8Experiments(ctx context.Context, namespace string, name string) (*http.Response, error) {
	req, err := NewPatchIter8ExperimentsRequest(c.Server, namespace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostIter8Experiments(ctx context.Context, namespace string) (*http.Response, error) {
	req, err := NewPostIter8ExperimentsRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetIter8Experiments(ctx context.Context, namespace string, name string) (*http.Response, error) {
	req, err := NewGetIter8ExperimentsRequest(c.Server, namespace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) JaegerInfo(ctx context.Context) (*http.Response, error) {
	req, err := NewJaegerInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) MeshTls(ctx context.Context) (*http.Response, error) {
	req, err := NewMeshTlsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NamespaceList(ctx context.Context) (*http.Response, error) {
	req, err := NewNamespaceListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GraphNamespaces(ctx context.Context, params *GraphNamespacesParams) (*http.Response, error) {
	req, err := NewGraphNamespacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GraphApp(ctx context.Context, namespace string, app string, params *GraphAppParams) (*http.Response, error) {
	req, err := NewGraphAppRequest(c.Server, namespace, app, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GraphAppVersion(ctx context.Context, namespace string, app string, version string, params *GraphAppVersionParams) (*http.Response, error) {
	req, err := NewGraphAppVersionRequest(c.Server, namespace, app, version, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppList(ctx context.Context, namespace string) (*http.Response, error) {
	req, err := NewAppListRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppDetails(ctx context.Context, namespace string, app string) (*http.Response, error) {
	req, err := NewAppDetailsRequest(c.Server, namespace, app)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppDashboard(ctx context.Context, namespace string, app string, params *AppDashboardParams) (*http.Response, error) {
	req, err := NewAppDashboardRequest(c.Server, namespace, app, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppHealth(ctx context.Context, namespace string, app string, params *AppHealthParams) (*http.Response, error) {
	req, err := NewAppHealthRequest(c.Server, namespace, app, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppMetrics(ctx context.Context, namespace string, app string, params *AppMetricsParams) (*http.Response, error) {
	req, err := NewAppMetricsRequest(c.Server, namespace, app, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CustomDashboard(ctx context.Context, namespace string, dashboard string, params *CustomDashboardParams) (*http.Response, error) {
	req, err := NewCustomDashboardRequest(c.Server, namespace, dashboard, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NamespaceHealth(ctx context.Context, namespace string, params *NamespaceHealthParams) (*http.Response, error) {
	req, err := NewNamespaceHealthRequest(c.Server, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IstioConfigList(ctx context.Context, namespace string) (*http.Response, error) {
	req, err := NewIstioConfigListRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IstioConfigCreate(ctx context.Context, namespace string, objectType string) (*http.Response, error) {
	req, err := NewIstioConfigCreateRequest(c.Server, namespace, objectType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IstioConfigCreateSubtype(ctx context.Context, namespace string, objectType string, objectSubtype string) (*http.Response, error) {
	req, err := NewIstioConfigCreateSubtypeRequest(c.Server, namespace, objectType, objectSubtype)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IstioConfigDeleteSubtype(ctx context.Context, namespace string, objectType string, objectSubtype string, object string) (*http.Response, error) {
	req, err := NewIstioConfigDeleteSubtypeRequest(c.Server, namespace, objectType, objectSubtype, object)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IstioConfigDetailsSubtype(ctx context.Context, namespace string, objectType string, objectSubtype string, object string) (*http.Response, error) {
	req, err := NewIstioConfigDetailsSubtypeRequest(c.Server, namespace, objectType, objectSubtype, object)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IstioConfigUpdateSubtype(ctx context.Context, namespace string, objectType string, objectSubtype string, object string) (*http.Response, error) {
	req, err := NewIstioConfigUpdateSubtypeRequest(c.Server, namespace, objectType, objectSubtype, object)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IstioConfigDelete(ctx context.Context, namespace string, objectType string, object string) (*http.Response, error) {
	req, err := NewIstioConfigDeleteRequest(c.Server, namespace, objectType, object)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IstioConfigDetails(ctx context.Context, namespace string, objectType string, object string) (*http.Response, error) {
	req, err := NewIstioConfigDetailsRequest(c.Server, namespace, objectType, object)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IstioConfigUpdate(ctx context.Context, namespace string, objectType string, object string) (*http.Response, error) {
	req, err := NewIstioConfigUpdateRequest(c.Server, namespace, objectType, object)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NamespaceMetrics(ctx context.Context, namespace string) (*http.Response, error) {
	req, err := NewNamespaceMetricsRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PodDetails(ctx context.Context, namespace string, pod string) (*http.Response, error) {
	req, err := NewPodDetailsRequest(c.Server, namespace, pod)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PodLogs(ctx context.Context, namespace string, pod string, params *PodLogsParams) (*http.Response, error) {
	req, err := NewPodLogsRequest(c.Server, namespace, pod, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceList(ctx context.Context, namespace string) (*http.Response, error) {
	req, err := NewServiceListRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceDetails(ctx context.Context, namespace string, service string) (*http.Response, error) {
	req, err := NewServiceDetailsRequest(c.Server, namespace, service)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceDashboard(ctx context.Context, namespace string, service string, params *ServiceDashboardParams) (*http.Response, error) {
	req, err := NewServiceDashboardRequest(c.Server, namespace, service, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ErrorTraces(ctx context.Context, namespace string, service string) (*http.Response, error) {
	req, err := NewErrorTracesRequest(c.Server, namespace, service)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GraphService(ctx context.Context, namespace string, service string, params *GraphServiceParams) (*http.Response, error) {
	req, err := NewGraphServiceRequest(c.Server, namespace, service, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceHealth(ctx context.Context, namespace string, service string, params *ServiceHealthParams) (*http.Response, error) {
	req, err := NewServiceHealthRequest(c.Server, namespace, service, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceMetrics(ctx context.Context, namespace string, service string, params *ServiceMetricsParams) (*http.Response, error) {
	req, err := NewServiceMetricsRequest(c.Server, namespace, service, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SpansList(ctx context.Context, namespace string, service string) (*http.Response, error) {
	req, err := NewSpansListRequest(c.Server, namespace, service)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) TracesDetail(ctx context.Context, namespace string, service string) (*http.Response, error) {
	req, err := NewTracesDetailRequest(c.Server, namespace, service)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NamespaceTls(ctx context.Context, namespace string) (*http.Response, error) {
	req, err := NewNamespaceTlsRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NamespaceValidations(ctx context.Context, namespace string) (*http.Response, error) {
	req, err := NewNamespaceValidationsRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) WorkloadList(ctx context.Context, namespace string) (*http.Response, error) {
	req, err := NewWorkloadListRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) WorkloadDetails(ctx context.Context, namespace string, workload string) (*http.Response, error) {
	req, err := NewWorkloadDetailsRequest(c.Server, namespace, workload)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) WorkloadDashboard(ctx context.Context, namespace string, workload string, params *WorkloadDashboardParams) (*http.Response, error) {
	req, err := NewWorkloadDashboardRequest(c.Server, namespace, workload, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GraphWorkload(ctx context.Context, namespace string, workload string, params *GraphWorkloadParams) (*http.Response, error) {
	req, err := NewGraphWorkloadRequest(c.Server, namespace, workload, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) WorkloadHealth(ctx context.Context, namespace string, workload string, params *WorkloadHealthParams) (*http.Response, error) {
	req, err := NewWorkloadHealthRequest(c.Server, namespace, workload, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) WorkloadMetrics(ctx context.Context, namespace string, workload string, params *WorkloadMetricsParams) (*http.Response, error) {
	req, err := NewWorkloadMetricsRequest(c.Server, namespace, workload, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetThreeScaleInfo(ctx context.Context) (*http.Response, error) {
	req, err := NewGetThreeScaleInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetThreeScaleHandlers(ctx context.Context) (*http.Response, error) {
	req, err := NewGetThreeScaleHandlersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostThreeScaleHandlers(ctx context.Context) (*http.Response, error) {
	req, err := NewPostThreeScaleHandlersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteThreeScaleHandler(ctx context.Context, threescaleHandlerName string) (*http.Response, error) {
	req, err := NewDeleteThreeScaleHandlerRequest(c.Server, threescaleHandlerName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PatchThreeScaleHandler(ctx context.Context, threescaleHandlerName string) (*http.Response, error) {
	req, err := NewPatchThreeScaleHandlerRequest(c.Server, threescaleHandlerName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostThreeScaleService(ctx context.Context, namespace string) (*http.Response, error) {
	req, err := NewPostThreeScaleServiceRequest(c.Server, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteThreeScaleService(ctx context.Context, namespace string, service string) (*http.Response, error) {
	req, err := NewDeleteThreeScaleServiceRequest(c.Server, namespace, service)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetThreeScaleService(ctx context.Context, namespace string, service string) (*http.Response, error) {
	req, err := NewGetThreeScaleServiceRequest(c.Server, namespace, service)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PatchThreeScaleService(ctx context.Context, namespace string, service string) (*http.Response, error) {
	req, err := NewPatchThreeScaleServiceRequest(c.Server, namespace, service)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewRootRequest generates requests for Root
func NewRootRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthenticationInfoRequest generates requests for AuthenticationInfo
func NewAuthenticationInfoRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/auth/info")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthenticateRequest generates requests for Authenticate
func NewAuthenticateRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/authenticate")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOpenshiftCheckTokenRequest generates requests for OpenshiftCheckToken
func NewOpenshiftCheckTokenRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/authenticate")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/config")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGrafanaInfoRequest generates requests for GrafanaInfo
func NewGrafanaInfoRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/grafana")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionsRequest generates requests for GetPermissions
func NewGetPermissionsRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/istio/permissions")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteIter8ExperimentsRequest generates requests for DeleteIter8Experiments
func NewDeleteIter8ExperimentsRequest(server string, namespace string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "name", name)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/iter8/experiments/namespaces/%s/name/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchIter8ExperimentsRequest generates requests for PatchIter8Experiments
func NewPatchIter8ExperimentsRequest(server string, namespace string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "name", name)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/iter8/experiments/%s/name/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostIter8ExperimentsRequest generates requests for PostIter8Experiments
func NewPostIter8ExperimentsRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/iter8/namespaces/%s/experiments", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIter8ExperimentsRequest generates requests for GetIter8Experiments
func NewGetIter8ExperimentsRequest(server string, namespace string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "name", name)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/iter8/namespaces/%s/experiments/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJaegerInfoRequest generates requests for JaegerInfo
func NewJaegerInfoRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/jaeger")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/logout")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeshTlsRequest generates requests for MeshTls
func NewMeshTlsRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/mesh/tls")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespaceListRequest generates requests for NamespaceList
func NewNamespaceListRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGraphNamespacesRequest generates requests for GraphNamespaces
func NewGraphNamespacesRequest(server string, params *GraphNamespacesParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/graph")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Appenders != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "appenders", *params.Appenders); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GraphType != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "graphType", *params.GraphType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GroupBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "groupBy", *params.GroupBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InjectServiceNodes != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "injectServiceNodes", *params.InjectServiceNodes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParam("form", true, "namespaces", params.Namespaces); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.QueryTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "queryTime", *params.QueryTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGraphAppRequest generates requests for GraphApp
func NewGraphAppRequest(server string, namespace string, app string, params *GraphAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "app", app)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/applications/%s/graph", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Appenders != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "appenders", *params.Appenders); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GraphType != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "graphType", *params.GraphType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GroupBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "groupBy", *params.GroupBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InjectServiceNodes != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "injectServiceNodes", *params.InjectServiceNodes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueryTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "queryTime", *params.QueryTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGraphAppVersionRequest generates requests for GraphAppVersion
func NewGraphAppVersionRequest(server string, namespace string, app string, version string, params *GraphAppVersionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "app", app)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "version", version)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/applications/%s/versions/%s/graph", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Appenders != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "appenders", *params.Appenders); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GraphType != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "graphType", *params.GraphType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GroupBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "groupBy", *params.GroupBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InjectServiceNodes != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "injectServiceNodes", *params.InjectServiceNodes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueryTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "queryTime", *params.QueryTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppListRequest generates requests for AppList
func NewAppListRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/apps", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppDetailsRequest generates requests for AppDetails
func NewAppDetailsRequest(server string, namespace string, app string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "app", app)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/apps/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppDashboardRequest generates requests for AppDashboard
func NewAppDashboardRequest(server string, namespace string, app string, params *AppDashboardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "app", app)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/apps/%s/dashboard", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Avg != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "avg", *params.Avg); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ByLabels != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "byLabels[]", *params.ByLabels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "direction", *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quantiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "quantiles[]", *params.Quantiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateFunc != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateFunc", *params.RateFunc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateInterval != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateInterval", *params.RateInterval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RequestProtocol != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "requestProtocol", *params.RequestProtocol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reporter != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "reporter", *params.Reporter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Step != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "step", *params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppHealthRequest generates requests for AppHealth
func NewAppHealthRequest(server string, namespace string, app string, params *AppHealthParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "app", app)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/apps/%s/health", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.RateInterval != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateInterval", *params.RateInterval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueryTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "QueryTime", *params.QueryTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppMetricsRequest generates requests for AppMetrics
func NewAppMetricsRequest(server string, namespace string, app string, params *AppMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "app", app)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/apps/%s/metrics", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Avg != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "avg", *params.Avg); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ByLabels != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "byLabels[]", *params.ByLabels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "direction", *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filters != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filters[]", *params.Filters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quantiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "quantiles[]", *params.Quantiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateFunc != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateFunc", *params.RateFunc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateInterval != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateInterval", *params.RateInterval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RequestProtocol != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "requestProtocol", *params.RequestProtocol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reporter != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "reporter", *params.Reporter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Step != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "step", *params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Version != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "version", *params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomDashboardRequest generates requests for CustomDashboard
func NewCustomDashboardRequest(server string, namespace string, dashboard string, params *CustomDashboardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "dashboard", dashboard)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/customdashboard/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.AdditionalLabels != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "additionalLabels", *params.AdditionalLabels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Avg != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "avg", *params.Avg); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ByLabels != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "byLabels[]", *params.ByLabels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LabelsFilters != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "labelsFilters", *params.LabelsFilters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quantiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "quantiles[]", *params.Quantiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateFunc != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateFunc", *params.RateFunc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateInterval != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateInterval", *params.RateInterval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Step != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "step", *params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespaceHealthRequest generates requests for NamespaceHealth
func NewNamespaceHealthRequest(server string, namespace string, params *NamespaceHealthParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/health", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.RateInterval != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateInterval", *params.RateInterval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueryTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "QueryTime", *params.QueryTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "type", *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIstioConfigListRequest generates requests for IstioConfigList
func NewIstioConfigListRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/istio", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIstioConfigCreateRequest generates requests for IstioConfigCreate
func NewIstioConfigCreateRequest(server string, namespace string, objectType string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "object_type", objectType)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/istio/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIstioConfigCreateSubtypeRequest generates requests for IstioConfigCreateSubtype
func NewIstioConfigCreateSubtypeRequest(server string, namespace string, objectType string, objectSubtype string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "object_type", objectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "object_subtype", objectSubtype)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/istio/%s/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIstioConfigDeleteSubtypeRequest generates requests for IstioConfigDeleteSubtype
func NewIstioConfigDeleteSubtypeRequest(server string, namespace string, objectType string, objectSubtype string, object string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "object_type", objectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "object_subtype", objectSubtype)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParam("simple", false, "object", object)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/istio/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIstioConfigDetailsSubtypeRequest generates requests for IstioConfigDetailsSubtype
func NewIstioConfigDetailsSubtypeRequest(server string, namespace string, objectType string, objectSubtype string, object string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "object_type", objectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "object_subtype", objectSubtype)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParam("simple", false, "object", object)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/istio/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIstioConfigUpdateSubtypeRequest generates requests for IstioConfigUpdateSubtype
func NewIstioConfigUpdateSubtypeRequest(server string, namespace string, objectType string, objectSubtype string, object string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "object_type", objectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "object_subtype", objectSubtype)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParam("simple", false, "object", object)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/istio/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIstioConfigDeleteRequest generates requests for IstioConfigDelete
func NewIstioConfigDeleteRequest(server string, namespace string, objectType string, object string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "object_type", objectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "object", object)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/istio/%s/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIstioConfigDetailsRequest generates requests for IstioConfigDetails
func NewIstioConfigDetailsRequest(server string, namespace string, objectType string, object string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "object_type", objectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "object", object)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/istio/%s/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIstioConfigUpdateRequest generates requests for IstioConfigUpdate
func NewIstioConfigUpdateRequest(server string, namespace string, objectType string, object string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "object_type", objectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "object", object)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/istio/%s/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespaceMetricsRequest generates requests for NamespaceMetrics
func NewNamespaceMetricsRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/metrics", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPodDetailsRequest generates requests for PodDetails
func NewPodDetailsRequest(server string, namespace string, pod string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "pod", pod)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/pods/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPodLogsRequest generates requests for PodLogs
func NewPodLogsRequest(server string, namespace string, pod string, params *PodLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "pod", pod)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/pods/%s/logs", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Container != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "container", *params.Container); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SinceTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sinceTime", *params.SinceTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServiceListRequest generates requests for ServiceList
func NewServiceListRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/services", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServiceDetailsRequest generates requests for ServiceDetails
func NewServiceDetailsRequest(server string, namespace string, service string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "service", service)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/services/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServiceDashboardRequest generates requests for ServiceDashboard
func NewServiceDashboardRequest(server string, namespace string, service string, params *ServiceDashboardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "service", service)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/services/%s/dashboard", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Avg != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "avg", *params.Avg); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ByLabels != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "byLabels[]", *params.ByLabels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "direction", *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quantiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "quantiles[]", *params.Quantiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateFunc != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateFunc", *params.RateFunc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateInterval != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateInterval", *params.RateInterval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RequestProtocol != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "requestProtocol", *params.RequestProtocol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reporter != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "reporter", *params.Reporter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Step != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "step", *params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewErrorTracesRequest generates requests for ErrorTraces
func NewErrorTracesRequest(server string, namespace string, service string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "service", service)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/services/%s/errortraces", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGraphServiceRequest generates requests for GraphService
func NewGraphServiceRequest(server string, namespace string, service string, params *GraphServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "service", service)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/services/%s/graph", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Appenders != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "appenders", *params.Appenders); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GraphType != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "graphType", *params.GraphType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GroupBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "groupBy", *params.GroupBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueryTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "queryTime", *params.QueryTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServiceHealthRequest generates requests for ServiceHealth
func NewServiceHealthRequest(server string, namespace string, service string, params *ServiceHealthParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "service", service)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/services/%s/health", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.RateInterval != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateInterval", *params.RateInterval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueryTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "QueryTime", *params.QueryTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServiceMetricsRequest generates requests for ServiceMetrics
func NewServiceMetricsRequest(server string, namespace string, service string, params *ServiceMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "service", service)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/services/%s/metrics", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Avg != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "avg", *params.Avg); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ByLabels != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "byLabels[]", *params.ByLabels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "direction", *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filters != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filters[]", *params.Filters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quantiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "quantiles[]", *params.Quantiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateFunc != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateFunc", *params.RateFunc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateInterval != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateInterval", *params.RateInterval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RequestProtocol != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "requestProtocol", *params.RequestProtocol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reporter != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "reporter", *params.Reporter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Step != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "step", *params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Version != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "version", *params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSpansListRequest generates requests for SpansList
func NewSpansListRequest(server string, namespace string, service string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "service", service)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/services/%s/spans", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTracesDetailRequest generates requests for TracesDetail
func NewTracesDetailRequest(server string, namespace string, service string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "service", service)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/services/%s/traces", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespaceTlsRequest generates requests for NamespaceTls
func NewNamespaceTlsRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/tls", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespaceValidationsRequest generates requests for NamespaceValidations
func NewNamespaceValidationsRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/validations", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkloadListRequest generates requests for WorkloadList
func NewWorkloadListRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/workloads", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkloadDetailsRequest generates requests for WorkloadDetails
func NewWorkloadDetailsRequest(server string, namespace string, workload string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "workload", workload)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/workloads/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkloadDashboardRequest generates requests for WorkloadDashboard
func NewWorkloadDashboardRequest(server string, namespace string, workload string, params *WorkloadDashboardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "workload", workload)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/workloads/%s/dashboard", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Avg != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "avg", *params.Avg); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ByLabels != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "byLabels[]", *params.ByLabels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "direction", *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quantiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "quantiles[]", *params.Quantiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateFunc != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateFunc", *params.RateFunc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateInterval != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateInterval", *params.RateInterval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RequestProtocol != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "requestProtocol", *params.RequestProtocol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reporter != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "reporter", *params.Reporter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Step != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "step", *params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGraphWorkloadRequest generates requests for GraphWorkload
func NewGraphWorkloadRequest(server string, namespace string, workload string, params *GraphWorkloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "workload", workload)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/workloads/%s/graph", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Appenders != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "appenders", *params.Appenders); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GraphType != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "graphType", *params.GraphType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GroupBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "groupBy", *params.GroupBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InjectServiceNodes != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "injectServiceNodes", *params.InjectServiceNodes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueryTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "queryTime", *params.QueryTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkloadHealthRequest generates requests for WorkloadHealth
func NewWorkloadHealthRequest(server string, namespace string, workload string, params *WorkloadHealthParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "workload", workload)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/workloads/%s/health", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.RateInterval != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateInterval", *params.RateInterval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueryTime != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "QueryTime", *params.QueryTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkloadMetricsRequest generates requests for WorkloadMetrics
func NewWorkloadMetricsRequest(server string, namespace string, workload string, params *WorkloadMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "workload", workload)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/namespaces/%s/workloads/%s/metrics", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Avg != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "avg", *params.Avg); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ByLabels != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "byLabels[]", *params.ByLabels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "direction", *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Duration != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "duration", *params.Duration); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filters != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filters[]", *params.Filters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quantiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "quantiles[]", *params.Quantiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateFunc != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateFunc", *params.RateFunc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RateInterval != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "rateInterval", *params.RateInterval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RequestProtocol != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "requestProtocol", *params.RequestProtocol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Reporter != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "reporter", *params.Reporter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Step != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "step", *params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Version != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "version", *params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/status")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThreeScaleInfoRequest generates requests for GetThreeScaleInfo
func NewGetThreeScaleInfoRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/threescale")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThreeScaleHandlersRequest generates requests for GetThreeScaleHandlers
func NewGetThreeScaleHandlersRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/threescale/handlers")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostThreeScaleHandlersRequest generates requests for PostThreeScaleHandlers
func NewPostThreeScaleHandlersRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/threescale/handlers")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteThreeScaleHandlerRequest generates requests for DeleteThreeScaleHandler
func NewDeleteThreeScaleHandlerRequest(server string, threescaleHandlerName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "threescaleHandlerName", threescaleHandlerName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/threescale/handlers/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchThreeScaleHandlerRequest generates requests for PatchThreeScaleHandler
func NewPatchThreeScaleHandlerRequest(server string, threescaleHandlerName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "threescaleHandlerName", threescaleHandlerName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/threescale/handlers/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostThreeScaleServiceRequest generates requests for PostThreeScaleService
func NewPostThreeScaleServiceRequest(server string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/threescale/namespaces/%s/services", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteThreeScaleServiceRequest generates requests for DeleteThreeScaleService
func NewDeleteThreeScaleServiceRequest(server string, namespace string, service string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "service", service)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/threescale/namespaces/%s/services/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThreeScaleServiceRequest generates requests for GetThreeScaleService
func NewGetThreeScaleServiceRequest(server string, namespace string, service string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "service", service)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/threescale/namespaces/%s/services/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchThreeScaleServiceRequest generates requests for PatchThreeScaleService
func NewPatchThreeScaleServiceRequest(server string, namespace string, service string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "namespace", namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "service", service)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/threescale/namespaces/%s/services/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		if !strings.HasSuffix(baseURL, "/") {
			baseURL += "/"
		}
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

type rootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusInfo
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r rootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r rootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type authenticationInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r authenticationInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r authenticationInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type authenticateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r authenticateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r authenticateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type openshiftCheckTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r openshiftCheckTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r openshiftCheckTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusInfo
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type grafanaInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GrafanaInfo
	JSON204      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON503 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r grafanaInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r grafanaInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IstioConfigPermissions
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteIter8ExperimentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r deleteIter8ExperimentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteIter8ExperimentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type patchIter8ExperimentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Iter8ExperimentDetail
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r patchIter8ExperimentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r patchIter8ExperimentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type postIter8ExperimentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Iter8ExperimentItem
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r postIter8ExperimentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r postIter8ExperimentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getIter8ExperimentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Iter8ExperimentDetail
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getIter8ExperimentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getIter8ExperimentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type jaegerInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JaegerInfo
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON406 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r jaegerInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r jaegerInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type logoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r logoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r logoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type meshTlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MTLSStatus
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r meshTlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r meshTlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type namespaceListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Namespace
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r namespaceListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r namespaceListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type graphNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r graphNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r graphNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type graphAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r graphAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r graphAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type graphAppVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r graphAppVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r graphAppVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type appListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppList
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r appListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r appListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type appDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r appDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r appDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type appDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MonitoringDashboard
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON503 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r appDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r appDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type appHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppHealth
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r appHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r appHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type appMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Metrics
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON503 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r appMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r appMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type customDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MonitoringDashboard
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON503 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r customDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r customDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type namespaceHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NamespaceAppHealth
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r namespaceHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r namespaceHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type istioConfigListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IstioConfigList
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r istioConfigListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r istioConfigListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type istioConfigCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IstioConfigDetails
	JSON201      *IstioConfigDetails
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r istioConfigCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r istioConfigCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type istioConfigCreateSubtypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IstioConfigDetails
	JSON201      *IstioConfigDetails
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r istioConfigCreateSubtypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r istioConfigCreateSubtypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type istioConfigDeleteSubtypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r istioConfigDeleteSubtypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r istioConfigDeleteSubtypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type istioConfigDetailsSubtypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IstioConfigDetails
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r istioConfigDetailsSubtypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r istioConfigDetailsSubtypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type istioConfigUpdateSubtypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IstioConfigDetails
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r istioConfigUpdateSubtypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r istioConfigUpdateSubtypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type istioConfigDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r istioConfigDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r istioConfigDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type istioConfigDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IstioConfigDetails
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r istioConfigDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r istioConfigDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type istioConfigUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IstioConfigDetails
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r istioConfigUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r istioConfigUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type namespaceMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Metrics
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON503 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r namespaceMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r namespaceMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type podDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workload
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r podDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r podDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type podLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workload
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r podLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r podLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type serviceListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceList
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r serviceListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r serviceListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type serviceDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceDetails
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r serviceDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r serviceDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type serviceDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MonitoringDashboard
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON503 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r serviceDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r serviceDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type errorTracesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r errorTracesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r errorTracesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type graphServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r graphServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r graphServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type serviceHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceHealth
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r serviceHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r serviceHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type serviceMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Metrics
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON503 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r serviceMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r serviceMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type spansListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Span
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r spansListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r spansListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type tracesDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Trace
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r tracesDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r tracesDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type namespaceTlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MTLSStatus
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r namespaceTlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r namespaceTlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type namespaceValidationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IstioValidationSummary
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r namespaceValidationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r namespaceValidationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type workloadListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkloadList
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r workloadListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r workloadListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type workloadDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workload
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r workloadDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r workloadDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type workloadDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MonitoringDashboard
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON503 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r workloadDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r workloadDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type graphWorkloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r graphWorkloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r graphWorkloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type workloadHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkloadHealth
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r workloadHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r workloadHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type workloadMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Metrics
	JSON400      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON503 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r workloadMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r workloadMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusInfo
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getThreeScaleInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreeScaleInfo
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getThreeScaleInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getThreeScaleInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getThreeScaleHandlersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreeScaleHandlers
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getThreeScaleHandlersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getThreeScaleHandlersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type postThreeScaleHandlersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreeScaleHandlers
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r postThreeScaleHandlersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r postThreeScaleHandlersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteThreeScaleHandlerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreeScaleHandlers
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r deleteThreeScaleHandlerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteThreeScaleHandlerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type patchThreeScaleHandlerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreeScaleHandlers
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r patchThreeScaleHandlerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r patchThreeScaleHandlerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type postThreeScaleServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreeScaleServiceRule
	JSON500      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r postThreeScaleServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r postThreeScaleServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteThreeScaleServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r deleteThreeScaleServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteThreeScaleServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getThreeScaleServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreeScaleServiceRule
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getThreeScaleServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getThreeScaleServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type patchThreeScaleServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreeScaleServiceRule
	JSON404      *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON500 *struct {

		// HTTP status code
		Code    *int32  `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r patchThreeScaleServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r patchThreeScaleServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// RootWithResponse request returning *RootResponse
func (c *ClientWithResponses) RootWithResponse(ctx context.Context) (*rootResponse, error) {
	rsp, err := c.Root(ctx)
	if err != nil {
		return nil, err
	}
	return ParseRootResponse(rsp)
}

// AuthenticationInfoWithResponse request returning *AuthenticationInfoResponse
func (c *ClientWithResponses) AuthenticationInfoWithResponse(ctx context.Context) (*authenticationInfoResponse, error) {
	rsp, err := c.AuthenticationInfo(ctx)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticationInfoResponse(rsp)
}

// AuthenticateWithResponse request returning *AuthenticateResponse
func (c *ClientWithResponses) AuthenticateWithResponse(ctx context.Context) (*authenticateResponse, error) {
	rsp, err := c.Authenticate(ctx)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateResponse(rsp)
}

// OpenshiftCheckTokenWithResponse request returning *OpenshiftCheckTokenResponse
func (c *ClientWithResponses) OpenshiftCheckTokenWithResponse(ctx context.Context) (*openshiftCheckTokenResponse, error) {
	rsp, err := c.OpenshiftCheckToken(ctx)
	if err != nil {
		return nil, err
	}
	return ParseOpenshiftCheckTokenResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context) (*getConfigResponse, error) {
	rsp, err := c.GetConfig(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GrafanaInfoWithResponse request returning *GrafanaInfoResponse
func (c *ClientWithResponses) GrafanaInfoWithResponse(ctx context.Context) (*grafanaInfoResponse, error) {
	rsp, err := c.GrafanaInfo(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGrafanaInfoResponse(rsp)
}

// GetPermissionsWithResponse request returning *GetPermissionsResponse
func (c *ClientWithResponses) GetPermissionsWithResponse(ctx context.Context) (*getPermissionsResponse, error) {
	rsp, err := c.GetPermissions(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionsResponse(rsp)
}

// DeleteIter8ExperimentsWithResponse request returning *DeleteIter8ExperimentsResponse
func (c *ClientWithResponses) DeleteIter8ExperimentsWithResponse(ctx context.Context, namespace string, name string) (*deleteIter8ExperimentsResponse, error) {
	rsp, err := c.DeleteIter8Experiments(ctx, namespace, name)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIter8ExperimentsResponse(rsp)
}

// PatchIter8ExperimentsWithResponse request returning *PatchIter8ExperimentsResponse
func (c *ClientWithResponses) PatchIter8ExperimentsWithResponse(ctx context.Context, namespace string, name string) (*patchIter8ExperimentsResponse, error) {
	rsp, err := c.PatchIter8Experiments(ctx, namespace, name)
	if err != nil {
		return nil, err
	}
	return ParsePatchIter8ExperimentsResponse(rsp)
}

// PostIter8ExperimentsWithResponse request returning *PostIter8ExperimentsResponse
func (c *ClientWithResponses) PostIter8ExperimentsWithResponse(ctx context.Context, namespace string) (*postIter8ExperimentsResponse, error) {
	rsp, err := c.PostIter8Experiments(ctx, namespace)
	if err != nil {
		return nil, err
	}
	return ParsePostIter8ExperimentsResponse(rsp)
}

// GetIter8ExperimentsWithResponse request returning *GetIter8ExperimentsResponse
func (c *ClientWithResponses) GetIter8ExperimentsWithResponse(ctx context.Context, namespace string, name string) (*getIter8ExperimentsResponse, error) {
	rsp, err := c.GetIter8Experiments(ctx, namespace, name)
	if err != nil {
		return nil, err
	}
	return ParseGetIter8ExperimentsResponse(rsp)
}

// JaegerInfoWithResponse request returning *JaegerInfoResponse
func (c *ClientWithResponses) JaegerInfoWithResponse(ctx context.Context) (*jaegerInfoResponse, error) {
	rsp, err := c.JaegerInfo(ctx)
	if err != nil {
		return nil, err
	}
	return ParseJaegerInfoResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context) (*logoutResponse, error) {
	rsp, err := c.Logout(ctx)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// MeshTlsWithResponse request returning *MeshTlsResponse
func (c *ClientWithResponses) MeshTlsWithResponse(ctx context.Context) (*meshTlsResponse, error) {
	rsp, err := c.MeshTls(ctx)
	if err != nil {
		return nil, err
	}
	return ParseMeshTlsResponse(rsp)
}

// NamespaceListWithResponse request returning *NamespaceListResponse
func (c *ClientWithResponses) NamespaceListWithResponse(ctx context.Context) (*namespaceListResponse, error) {
	rsp, err := c.NamespaceList(ctx)
	if err != nil {
		return nil, err
	}
	return ParseNamespaceListResponse(rsp)
}

// GraphNamespacesWithResponse request returning *GraphNamespacesResponse
func (c *ClientWithResponses) GraphNamespacesWithResponse(ctx context.Context, params *GraphNamespacesParams) (*graphNamespacesResponse, error) {
	rsp, err := c.GraphNamespaces(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGraphNamespacesResponse(rsp)
}

// GraphAppWithResponse request returning *GraphAppResponse
func (c *ClientWithResponses) GraphAppWithResponse(ctx context.Context, namespace string, app string, params *GraphAppParams) (*graphAppResponse, error) {
	rsp, err := c.GraphApp(ctx, namespace, app, params)
	if err != nil {
		return nil, err
	}
	return ParseGraphAppResponse(rsp)
}

// GraphAppVersionWithResponse request returning *GraphAppVersionResponse
func (c *ClientWithResponses) GraphAppVersionWithResponse(ctx context.Context, namespace string, app string, version string, params *GraphAppVersionParams) (*graphAppVersionResponse, error) {
	rsp, err := c.GraphAppVersion(ctx, namespace, app, version, params)
	if err != nil {
		return nil, err
	}
	return ParseGraphAppVersionResponse(rsp)
}

// AppListWithResponse request returning *AppListResponse
func (c *ClientWithResponses) AppListWithResponse(ctx context.Context, namespace string) (*appListResponse, error) {
	rsp, err := c.AppList(ctx, namespace)
	if err != nil {
		return nil, err
	}
	return ParseAppListResponse(rsp)
}

// AppDetailsWithResponse request returning *AppDetailsResponse
func (c *ClientWithResponses) AppDetailsWithResponse(ctx context.Context, namespace string, app string) (*appDetailsResponse, error) {
	rsp, err := c.AppDetails(ctx, namespace, app)
	if err != nil {
		return nil, err
	}
	return ParseAppDetailsResponse(rsp)
}

// AppDashboardWithResponse request returning *AppDashboardResponse
func (c *ClientWithResponses) AppDashboardWithResponse(ctx context.Context, namespace string, app string, params *AppDashboardParams) (*appDashboardResponse, error) {
	rsp, err := c.AppDashboard(ctx, namespace, app, params)
	if err != nil {
		return nil, err
	}
	return ParseAppDashboardResponse(rsp)
}

// AppHealthWithResponse request returning *AppHealthResponse
func (c *ClientWithResponses) AppHealthWithResponse(ctx context.Context, namespace string, app string, params *AppHealthParams) (*appHealthResponse, error) {
	rsp, err := c.AppHealth(ctx, namespace, app, params)
	if err != nil {
		return nil, err
	}
	return ParseAppHealthResponse(rsp)
}

// AppMetricsWithResponse request returning *AppMetricsResponse
func (c *ClientWithResponses) AppMetricsWithResponse(ctx context.Context, namespace string, app string, params *AppMetricsParams) (*appMetricsResponse, error) {
	rsp, err := c.AppMetrics(ctx, namespace, app, params)
	if err != nil {
		return nil, err
	}
	return ParseAppMetricsResponse(rsp)
}

// CustomDashboardWithResponse request returning *CustomDashboardResponse
func (c *ClientWithResponses) CustomDashboardWithResponse(ctx context.Context, namespace string, dashboard string, params *CustomDashboardParams) (*customDashboardResponse, error) {
	rsp, err := c.CustomDashboard(ctx, namespace, dashboard, params)
	if err != nil {
		return nil, err
	}
	return ParseCustomDashboardResponse(rsp)
}

// NamespaceHealthWithResponse request returning *NamespaceHealthResponse
func (c *ClientWithResponses) NamespaceHealthWithResponse(ctx context.Context, namespace string, params *NamespaceHealthParams) (*namespaceHealthResponse, error) {
	rsp, err := c.NamespaceHealth(ctx, namespace, params)
	if err != nil {
		return nil, err
	}
	return ParseNamespaceHealthResponse(rsp)
}

// IstioConfigListWithResponse request returning *IstioConfigListResponse
func (c *ClientWithResponses) IstioConfigListWithResponse(ctx context.Context, namespace string) (*istioConfigListResponse, error) {
	rsp, err := c.IstioConfigList(ctx, namespace)
	if err != nil {
		return nil, err
	}
	return ParseIstioConfigListResponse(rsp)
}

// IstioConfigCreateWithResponse request returning *IstioConfigCreateResponse
func (c *ClientWithResponses) IstioConfigCreateWithResponse(ctx context.Context, namespace string, objectType string) (*istioConfigCreateResponse, error) {
	rsp, err := c.IstioConfigCreate(ctx, namespace, objectType)
	if err != nil {
		return nil, err
	}
	return ParseIstioConfigCreateResponse(rsp)
}

// IstioConfigCreateSubtypeWithResponse request returning *IstioConfigCreateSubtypeResponse
func (c *ClientWithResponses) IstioConfigCreateSubtypeWithResponse(ctx context.Context, namespace string, objectType string, objectSubtype string) (*istioConfigCreateSubtypeResponse, error) {
	rsp, err := c.IstioConfigCreateSubtype(ctx, namespace, objectType, objectSubtype)
	if err != nil {
		return nil, err
	}
	return ParseIstioConfigCreateSubtypeResponse(rsp)
}

// IstioConfigDeleteSubtypeWithResponse request returning *IstioConfigDeleteSubtypeResponse
func (c *ClientWithResponses) IstioConfigDeleteSubtypeWithResponse(ctx context.Context, namespace string, objectType string, objectSubtype string, object string) (*istioConfigDeleteSubtypeResponse, error) {
	rsp, err := c.IstioConfigDeleteSubtype(ctx, namespace, objectType, objectSubtype, object)
	if err != nil {
		return nil, err
	}
	return ParseIstioConfigDeleteSubtypeResponse(rsp)
}

// IstioConfigDetailsSubtypeWithResponse request returning *IstioConfigDetailsSubtypeResponse
func (c *ClientWithResponses) IstioConfigDetailsSubtypeWithResponse(ctx context.Context, namespace string, objectType string, objectSubtype string, object string) (*istioConfigDetailsSubtypeResponse, error) {
	rsp, err := c.IstioConfigDetailsSubtype(ctx, namespace, objectType, objectSubtype, object)
	if err != nil {
		return nil, err
	}
	return ParseIstioConfigDetailsSubtypeResponse(rsp)
}

// IstioConfigUpdateSubtypeWithResponse request returning *IstioConfigUpdateSubtypeResponse
func (c *ClientWithResponses) IstioConfigUpdateSubtypeWithResponse(ctx context.Context, namespace string, objectType string, objectSubtype string, object string) (*istioConfigUpdateSubtypeResponse, error) {
	rsp, err := c.IstioConfigUpdateSubtype(ctx, namespace, objectType, objectSubtype, object)
	if err != nil {
		return nil, err
	}
	return ParseIstioConfigUpdateSubtypeResponse(rsp)
}

// IstioConfigDeleteWithResponse request returning *IstioConfigDeleteResponse
func (c *ClientWithResponses) IstioConfigDeleteWithResponse(ctx context.Context, namespace string, objectType string, object string) (*istioConfigDeleteResponse, error) {
	rsp, err := c.IstioConfigDelete(ctx, namespace, objectType, object)
	if err != nil {
		return nil, err
	}
	return ParseIstioConfigDeleteResponse(rsp)
}

// IstioConfigDetailsWithResponse request returning *IstioConfigDetailsResponse
func (c *ClientWithResponses) IstioConfigDetailsWithResponse(ctx context.Context, namespace string, objectType string, object string) (*istioConfigDetailsResponse, error) {
	rsp, err := c.IstioConfigDetails(ctx, namespace, objectType, object)
	if err != nil {
		return nil, err
	}
	return ParseIstioConfigDetailsResponse(rsp)
}

// IstioConfigUpdateWithResponse request returning *IstioConfigUpdateResponse
func (c *ClientWithResponses) IstioConfigUpdateWithResponse(ctx context.Context, namespace string, objectType string, object string) (*istioConfigUpdateResponse, error) {
	rsp, err := c.IstioConfigUpdate(ctx, namespace, objectType, object)
	if err != nil {
		return nil, err
	}
	return ParseIstioConfigUpdateResponse(rsp)
}

// NamespaceMetricsWithResponse request returning *NamespaceMetricsResponse
func (c *ClientWithResponses) NamespaceMetricsWithResponse(ctx context.Context, namespace string) (*namespaceMetricsResponse, error) {
	rsp, err := c.NamespaceMetrics(ctx, namespace)
	if err != nil {
		return nil, err
	}
	return ParseNamespaceMetricsResponse(rsp)
}

// PodDetailsWithResponse request returning *PodDetailsResponse
func (c *ClientWithResponses) PodDetailsWithResponse(ctx context.Context, namespace string, pod string) (*podDetailsResponse, error) {
	rsp, err := c.PodDetails(ctx, namespace, pod)
	if err != nil {
		return nil, err
	}
	return ParsePodDetailsResponse(rsp)
}

// PodLogsWithResponse request returning *PodLogsResponse
func (c *ClientWithResponses) PodLogsWithResponse(ctx context.Context, namespace string, pod string, params *PodLogsParams) (*podLogsResponse, error) {
	rsp, err := c.PodLogs(ctx, namespace, pod, params)
	if err != nil {
		return nil, err
	}
	return ParsePodLogsResponse(rsp)
}

// ServiceListWithResponse request returning *ServiceListResponse
func (c *ClientWithResponses) ServiceListWithResponse(ctx context.Context, namespace string) (*serviceListResponse, error) {
	rsp, err := c.ServiceList(ctx, namespace)
	if err != nil {
		return nil, err
	}
	return ParseServiceListResponse(rsp)
}

// ServiceDetailsWithResponse request returning *ServiceDetailsResponse
func (c *ClientWithResponses) ServiceDetailsWithResponse(ctx context.Context, namespace string, service string) (*serviceDetailsResponse, error) {
	rsp, err := c.ServiceDetails(ctx, namespace, service)
	if err != nil {
		return nil, err
	}
	return ParseServiceDetailsResponse(rsp)
}

// ServiceDashboardWithResponse request returning *ServiceDashboardResponse
func (c *ClientWithResponses) ServiceDashboardWithResponse(ctx context.Context, namespace string, service string, params *ServiceDashboardParams) (*serviceDashboardResponse, error) {
	rsp, err := c.ServiceDashboard(ctx, namespace, service, params)
	if err != nil {
		return nil, err
	}
	return ParseServiceDashboardResponse(rsp)
}

// ErrorTracesWithResponse request returning *ErrorTracesResponse
func (c *ClientWithResponses) ErrorTracesWithResponse(ctx context.Context, namespace string, service string) (*errorTracesResponse, error) {
	rsp, err := c.ErrorTraces(ctx, namespace, service)
	if err != nil {
		return nil, err
	}
	return ParseErrorTracesResponse(rsp)
}

// GraphServiceWithResponse request returning *GraphServiceResponse
func (c *ClientWithResponses) GraphServiceWithResponse(ctx context.Context, namespace string, service string, params *GraphServiceParams) (*graphServiceResponse, error) {
	rsp, err := c.GraphService(ctx, namespace, service, params)
	if err != nil {
		return nil, err
	}
	return ParseGraphServiceResponse(rsp)
}

// ServiceHealthWithResponse request returning *ServiceHealthResponse
func (c *ClientWithResponses) ServiceHealthWithResponse(ctx context.Context, namespace string, service string, params *ServiceHealthParams) (*serviceHealthResponse, error) {
	rsp, err := c.ServiceHealth(ctx, namespace, service, params)
	if err != nil {
		return nil, err
	}
	return ParseServiceHealthResponse(rsp)
}

// ServiceMetricsWithResponse request returning *ServiceMetricsResponse
func (c *ClientWithResponses) ServiceMetricsWithResponse(ctx context.Context, namespace string, service string, params *ServiceMetricsParams) (*serviceMetricsResponse, error) {
	rsp, err := c.ServiceMetrics(ctx, namespace, service, params)
	if err != nil {
		return nil, err
	}
	return ParseServiceMetricsResponse(rsp)
}

// SpansListWithResponse request returning *SpansListResponse
func (c *ClientWithResponses) SpansListWithResponse(ctx context.Context, namespace string, service string) (*spansListResponse, error) {
	rsp, err := c.SpansList(ctx, namespace, service)
	if err != nil {
		return nil, err
	}
	return ParseSpansListResponse(rsp)
}

// TracesDetailWithResponse request returning *TracesDetailResponse
func (c *ClientWithResponses) TracesDetailWithResponse(ctx context.Context, namespace string, service string) (*tracesDetailResponse, error) {
	rsp, err := c.TracesDetail(ctx, namespace, service)
	if err != nil {
		return nil, err
	}
	return ParseTracesDetailResponse(rsp)
}

// NamespaceTlsWithResponse request returning *NamespaceTlsResponse
func (c *ClientWithResponses) NamespaceTlsWithResponse(ctx context.Context, namespace string) (*namespaceTlsResponse, error) {
	rsp, err := c.NamespaceTls(ctx, namespace)
	if err != nil {
		return nil, err
	}
	return ParseNamespaceTlsResponse(rsp)
}

// NamespaceValidationsWithResponse request returning *NamespaceValidationsResponse
func (c *ClientWithResponses) NamespaceValidationsWithResponse(ctx context.Context, namespace string) (*namespaceValidationsResponse, error) {
	rsp, err := c.NamespaceValidations(ctx, namespace)
	if err != nil {
		return nil, err
	}
	return ParseNamespaceValidationsResponse(rsp)
}

// WorkloadListWithResponse request returning *WorkloadListResponse
func (c *ClientWithResponses) WorkloadListWithResponse(ctx context.Context, namespace string) (*workloadListResponse, error) {
	rsp, err := c.WorkloadList(ctx, namespace)
	if err != nil {
		return nil, err
	}
	return ParseWorkloadListResponse(rsp)
}

// WorkloadDetailsWithResponse request returning *WorkloadDetailsResponse
func (c *ClientWithResponses) WorkloadDetailsWithResponse(ctx context.Context, namespace string, workload string) (*workloadDetailsResponse, error) {
	rsp, err := c.WorkloadDetails(ctx, namespace, workload)
	if err != nil {
		return nil, err
	}
	return ParseWorkloadDetailsResponse(rsp)
}

// WorkloadDashboardWithResponse request returning *WorkloadDashboardResponse
func (c *ClientWithResponses) WorkloadDashboardWithResponse(ctx context.Context, namespace string, workload string, params *WorkloadDashboardParams) (*workloadDashboardResponse, error) {
	rsp, err := c.WorkloadDashboard(ctx, namespace, workload, params)
	if err != nil {
		return nil, err
	}
	return ParseWorkloadDashboardResponse(rsp)
}

// GraphWorkloadWithResponse request returning *GraphWorkloadResponse
func (c *ClientWithResponses) GraphWorkloadWithResponse(ctx context.Context, namespace string, workload string, params *GraphWorkloadParams) (*graphWorkloadResponse, error) {
	rsp, err := c.GraphWorkload(ctx, namespace, workload, params)
	if err != nil {
		return nil, err
	}
	return ParseGraphWorkloadResponse(rsp)
}

// WorkloadHealthWithResponse request returning *WorkloadHealthResponse
func (c *ClientWithResponses) WorkloadHealthWithResponse(ctx context.Context, namespace string, workload string, params *WorkloadHealthParams) (*workloadHealthResponse, error) {
	rsp, err := c.WorkloadHealth(ctx, namespace, workload, params)
	if err != nil {
		return nil, err
	}
	return ParseWorkloadHealthResponse(rsp)
}

// WorkloadMetricsWithResponse request returning *WorkloadMetricsResponse
func (c *ClientWithResponses) WorkloadMetricsWithResponse(ctx context.Context, namespace string, workload string, params *WorkloadMetricsParams) (*workloadMetricsResponse, error) {
	rsp, err := c.WorkloadMetrics(ctx, namespace, workload, params)
	if err != nil {
		return nil, err
	}
	return ParseWorkloadMetricsResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context) (*getStatusResponse, error) {
	rsp, err := c.GetStatus(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// GetThreeScaleInfoWithResponse request returning *GetThreeScaleInfoResponse
func (c *ClientWithResponses) GetThreeScaleInfoWithResponse(ctx context.Context) (*getThreeScaleInfoResponse, error) {
	rsp, err := c.GetThreeScaleInfo(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetThreeScaleInfoResponse(rsp)
}

// GetThreeScaleHandlersWithResponse request returning *GetThreeScaleHandlersResponse
func (c *ClientWithResponses) GetThreeScaleHandlersWithResponse(ctx context.Context) (*getThreeScaleHandlersResponse, error) {
	rsp, err := c.GetThreeScaleHandlers(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetThreeScaleHandlersResponse(rsp)
}

// PostThreeScaleHandlersWithResponse request returning *PostThreeScaleHandlersResponse
func (c *ClientWithResponses) PostThreeScaleHandlersWithResponse(ctx context.Context) (*postThreeScaleHandlersResponse, error) {
	rsp, err := c.PostThreeScaleHandlers(ctx)
	if err != nil {
		return nil, err
	}
	return ParsePostThreeScaleHandlersResponse(rsp)
}

// DeleteThreeScaleHandlerWithResponse request returning *DeleteThreeScaleHandlerResponse
func (c *ClientWithResponses) DeleteThreeScaleHandlerWithResponse(ctx context.Context, threescaleHandlerName string) (*deleteThreeScaleHandlerResponse, error) {
	rsp, err := c.DeleteThreeScaleHandler(ctx, threescaleHandlerName)
	if err != nil {
		return nil, err
	}
	return ParseDeleteThreeScaleHandlerResponse(rsp)
}

// PatchThreeScaleHandlerWithResponse request returning *PatchThreeScaleHandlerResponse
func (c *ClientWithResponses) PatchThreeScaleHandlerWithResponse(ctx context.Context, threescaleHandlerName string) (*patchThreeScaleHandlerResponse, error) {
	rsp, err := c.PatchThreeScaleHandler(ctx, threescaleHandlerName)
	if err != nil {
		return nil, err
	}
	return ParsePatchThreeScaleHandlerResponse(rsp)
}

// PostThreeScaleServiceWithResponse request returning *PostThreeScaleServiceResponse
func (c *ClientWithResponses) PostThreeScaleServiceWithResponse(ctx context.Context, namespace string) (*postThreeScaleServiceResponse, error) {
	rsp, err := c.PostThreeScaleService(ctx, namespace)
	if err != nil {
		return nil, err
	}
	return ParsePostThreeScaleServiceResponse(rsp)
}

// DeleteThreeScaleServiceWithResponse request returning *DeleteThreeScaleServiceResponse
func (c *ClientWithResponses) DeleteThreeScaleServiceWithResponse(ctx context.Context, namespace string, service string) (*deleteThreeScaleServiceResponse, error) {
	rsp, err := c.DeleteThreeScaleService(ctx, namespace, service)
	if err != nil {
		return nil, err
	}
	return ParseDeleteThreeScaleServiceResponse(rsp)
}

// GetThreeScaleServiceWithResponse request returning *GetThreeScaleServiceResponse
func (c *ClientWithResponses) GetThreeScaleServiceWithResponse(ctx context.Context, namespace string, service string) (*getThreeScaleServiceResponse, error) {
	rsp, err := c.GetThreeScaleService(ctx, namespace, service)
	if err != nil {
		return nil, err
	}
	return ParseGetThreeScaleServiceResponse(rsp)
}

// PatchThreeScaleServiceWithResponse request returning *PatchThreeScaleServiceResponse
func (c *ClientWithResponses) PatchThreeScaleServiceWithResponse(ctx context.Context, namespace string, service string) (*patchThreeScaleServiceResponse, error) {
	rsp, err := c.PatchThreeScaleService(ctx, namespace, service)
	if err != nil {
		return nil, err
	}
	return ParsePatchThreeScaleServiceResponse(rsp)
}

// ParseRootResponse parses an HTTP response from a RootWithResponse call
func ParseRootResponse(rsp *http.Response) (*rootResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &rootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthenticationInfoResponse parses an HTTP response from a AuthenticationInfoWithResponse call
func ParseAuthenticationInfoResponse(rsp *http.Response) (*authenticationInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &authenticationInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthenticateResponse parses an HTTP response from a AuthenticateWithResponse call
func ParseAuthenticateResponse(rsp *http.Response) (*authenticateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &authenticateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOpenshiftCheckTokenResponse parses an HTTP response from a OpenshiftCheckTokenWithResponse call
func ParseOpenshiftCheckTokenResponse(rsp *http.Response) (*openshiftCheckTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &openshiftCheckTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*getConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGrafanaInfoResponse parses an HTTP response from a GrafanaInfoWithResponse call
func ParseGrafanaInfoResponse(rsp *http.Response) (*grafanaInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &grafanaInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GrafanaInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPermissionsResponse parses an HTTP response from a GetPermissionsWithResponse call
func ParseGetPermissionsResponse(rsp *http.Response) (*getPermissionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IstioConfigPermissions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteIter8ExperimentsResponse parses an HTTP response from a DeleteIter8ExperimentsWithResponse call
func ParseDeleteIter8ExperimentsResponse(rsp *http.Response) (*deleteIter8ExperimentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteIter8ExperimentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchIter8ExperimentsResponse parses an HTTP response from a PatchIter8ExperimentsWithResponse call
func ParsePatchIter8ExperimentsResponse(rsp *http.Response) (*patchIter8ExperimentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &patchIter8ExperimentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Iter8ExperimentDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostIter8ExperimentsResponse parses an HTTP response from a PostIter8ExperimentsWithResponse call
func ParsePostIter8ExperimentsResponse(rsp *http.Response) (*postIter8ExperimentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &postIter8ExperimentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Iter8ExperimentItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIter8ExperimentsResponse parses an HTTP response from a GetIter8ExperimentsWithResponse call
func ParseGetIter8ExperimentsResponse(rsp *http.Response) (*getIter8ExperimentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getIter8ExperimentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Iter8ExperimentDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseJaegerInfoResponse parses an HTTP response from a JaegerInfoWithResponse call
func ParseJaegerInfoResponse(rsp *http.Response) (*jaegerInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &jaegerInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JaegerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*logoutResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &logoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	}

	return response, nil
}

// ParseMeshTlsResponse parses an HTTP response from a MeshTlsWithResponse call
func ParseMeshTlsResponse(rsp *http.Response) (*meshTlsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &meshTlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MTLSStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseNamespaceListResponse parses an HTTP response from a NamespaceListWithResponse call
func ParseNamespaceListResponse(rsp *http.Response) (*namespaceListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &namespaceListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Namespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGraphNamespacesResponse parses an HTTP response from a GraphNamespacesWithResponse call
func ParseGraphNamespacesResponse(rsp *http.Response) (*graphNamespacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &graphNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGraphAppResponse parses an HTTP response from a GraphAppWithResponse call
func ParseGraphAppResponse(rsp *http.Response) (*graphAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &graphAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGraphAppVersionResponse parses an HTTP response from a GraphAppVersionWithResponse call
func ParseGraphAppVersionResponse(rsp *http.Response) (*graphAppVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &graphAppVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppListResponse parses an HTTP response from a AppListWithResponse call
func ParseAppListResponse(rsp *http.Response) (*appListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &appListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppDetailsResponse parses an HTTP response from a AppDetailsWithResponse call
func ParseAppDetailsResponse(rsp *http.Response) (*appDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &appDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppDashboardResponse parses an HTTP response from a AppDashboardWithResponse call
func ParseAppDashboardResponse(rsp *http.Response) (*appDashboardResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &appDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MonitoringDashboard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseAppHealthResponse parses an HTTP response from a AppHealthWithResponse call
func ParseAppHealthResponse(rsp *http.Response) (*appHealthResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &appHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppHealth
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppMetricsResponse parses an HTTP response from a AppMetricsWithResponse call
func ParseAppMetricsResponse(rsp *http.Response) (*appMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &appMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCustomDashboardResponse parses an HTTP response from a CustomDashboardWithResponse call
func ParseCustomDashboardResponse(rsp *http.Response) (*customDashboardResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &customDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MonitoringDashboard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseNamespaceHealthResponse parses an HTTP response from a NamespaceHealthWithResponse call
func ParseNamespaceHealthResponse(rsp *http.Response) (*namespaceHealthResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &namespaceHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NamespaceAppHealth
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIstioConfigListResponse parses an HTTP response from a IstioConfigListWithResponse call
func ParseIstioConfigListResponse(rsp *http.Response) (*istioConfigListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &istioConfigListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IstioConfigList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIstioConfigCreateResponse parses an HTTP response from a IstioConfigCreateWithResponse call
func ParseIstioConfigCreateResponse(rsp *http.Response) (*istioConfigCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &istioConfigCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IstioConfigDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IstioConfigDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIstioConfigCreateSubtypeResponse parses an HTTP response from a IstioConfigCreateSubtypeWithResponse call
func ParseIstioConfigCreateSubtypeResponse(rsp *http.Response) (*istioConfigCreateSubtypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &istioConfigCreateSubtypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IstioConfigDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IstioConfigDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIstioConfigDeleteSubtypeResponse parses an HTTP response from a IstioConfigDeleteSubtypeWithResponse call
func ParseIstioConfigDeleteSubtypeResponse(rsp *http.Response) (*istioConfigDeleteSubtypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &istioConfigDeleteSubtypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIstioConfigDetailsSubtypeResponse parses an HTTP response from a IstioConfigDetailsSubtypeWithResponse call
func ParseIstioConfigDetailsSubtypeResponse(rsp *http.Response) (*istioConfigDetailsSubtypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &istioConfigDetailsSubtypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IstioConfigDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIstioConfigUpdateSubtypeResponse parses an HTTP response from a IstioConfigUpdateSubtypeWithResponse call
func ParseIstioConfigUpdateSubtypeResponse(rsp *http.Response) (*istioConfigUpdateSubtypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &istioConfigUpdateSubtypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IstioConfigDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIstioConfigDeleteResponse parses an HTTP response from a IstioConfigDeleteWithResponse call
func ParseIstioConfigDeleteResponse(rsp *http.Response) (*istioConfigDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &istioConfigDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIstioConfigDetailsResponse parses an HTTP response from a IstioConfigDetailsWithResponse call
func ParseIstioConfigDetailsResponse(rsp *http.Response) (*istioConfigDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &istioConfigDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IstioConfigDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIstioConfigUpdateResponse parses an HTTP response from a IstioConfigUpdateWithResponse call
func ParseIstioConfigUpdateResponse(rsp *http.Response) (*istioConfigUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &istioConfigUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IstioConfigDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseNamespaceMetricsResponse parses an HTTP response from a NamespaceMetricsWithResponse call
func ParseNamespaceMetricsResponse(rsp *http.Response) (*namespaceMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &namespaceMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePodDetailsResponse parses an HTTP response from a PodDetailsWithResponse call
func ParsePodDetailsResponse(rsp *http.Response) (*podDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &podDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePodLogsResponse parses an HTTP response from a PodLogsWithResponse call
func ParsePodLogsResponse(rsp *http.Response) (*podLogsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &podLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseServiceListResponse parses an HTTP response from a ServiceListWithResponse call
func ParseServiceListResponse(rsp *http.Response) (*serviceListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &serviceListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseServiceDetailsResponse parses an HTTP response from a ServiceDetailsWithResponse call
func ParseServiceDetailsResponse(rsp *http.Response) (*serviceDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &serviceDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseServiceDashboardResponse parses an HTTP response from a ServiceDashboardWithResponse call
func ParseServiceDashboardResponse(rsp *http.Response) (*serviceDashboardResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &serviceDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MonitoringDashboard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseErrorTracesResponse parses an HTTP response from a ErrorTracesWithResponse call
func ParseErrorTracesResponse(rsp *http.Response) (*errorTracesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &errorTracesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGraphServiceResponse parses an HTTP response from a GraphServiceWithResponse call
func ParseGraphServiceResponse(rsp *http.Response) (*graphServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &graphServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseServiceHealthResponse parses an HTTP response from a ServiceHealthWithResponse call
func ParseServiceHealthResponse(rsp *http.Response) (*serviceHealthResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &serviceHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceHealth
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseServiceMetricsResponse parses an HTTP response from a ServiceMetricsWithResponse call
func ParseServiceMetricsResponse(rsp *http.Response) (*serviceMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &serviceMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSpansListResponse parses an HTTP response from a SpansListWithResponse call
func ParseSpansListResponse(rsp *http.Response) (*spansListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &spansListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Span
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTracesDetailResponse parses an HTTP response from a TracesDetailWithResponse call
func ParseTracesDetailResponse(rsp *http.Response) (*tracesDetailResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &tracesDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Trace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseNamespaceTlsResponse parses an HTTP response from a NamespaceTlsWithResponse call
func ParseNamespaceTlsResponse(rsp *http.Response) (*namespaceTlsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &namespaceTlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MTLSStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseNamespaceValidationsResponse parses an HTTP response from a NamespaceValidationsWithResponse call
func ParseNamespaceValidationsResponse(rsp *http.Response) (*namespaceValidationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &namespaceValidationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IstioValidationSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWorkloadListResponse parses an HTTP response from a WorkloadListWithResponse call
func ParseWorkloadListResponse(rsp *http.Response) (*workloadListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &workloadListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkloadList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWorkloadDetailsResponse parses an HTTP response from a WorkloadDetailsWithResponse call
func ParseWorkloadDetailsResponse(rsp *http.Response) (*workloadDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &workloadDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWorkloadDashboardResponse parses an HTTP response from a WorkloadDashboardWithResponse call
func ParseWorkloadDashboardResponse(rsp *http.Response) (*workloadDashboardResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &workloadDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MonitoringDashboard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGraphWorkloadResponse parses an HTTP response from a GraphWorkloadWithResponse call
func ParseGraphWorkloadResponse(rsp *http.Response) (*graphWorkloadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &graphWorkloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWorkloadHealthResponse parses an HTTP response from a WorkloadHealthWithResponse call
func ParseWorkloadHealthResponse(rsp *http.Response) (*workloadHealthResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &workloadHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkloadHealth
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWorkloadMetricsResponse parses an HTTP response from a WorkloadMetricsWithResponse call
func ParseWorkloadMetricsResponse(rsp *http.Response) (*workloadMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &workloadMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*getStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetThreeScaleInfoResponse parses an HTTP response from a GetThreeScaleInfoWithResponse call
func ParseGetThreeScaleInfoResponse(rsp *http.Response) (*getThreeScaleInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getThreeScaleInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreeScaleInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetThreeScaleHandlersResponse parses an HTTP response from a GetThreeScaleHandlersWithResponse call
func ParseGetThreeScaleHandlersResponse(rsp *http.Response) (*getThreeScaleHandlersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getThreeScaleHandlersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreeScaleHandlers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostThreeScaleHandlersResponse parses an HTTP response from a PostThreeScaleHandlersWithResponse call
func ParsePostThreeScaleHandlersResponse(rsp *http.Response) (*postThreeScaleHandlersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &postThreeScaleHandlersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreeScaleHandlers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteThreeScaleHandlerResponse parses an HTTP response from a DeleteThreeScaleHandlerWithResponse call
func ParseDeleteThreeScaleHandlerResponse(rsp *http.Response) (*deleteThreeScaleHandlerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteThreeScaleHandlerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreeScaleHandlers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchThreeScaleHandlerResponse parses an HTTP response from a PatchThreeScaleHandlerWithResponse call
func ParsePatchThreeScaleHandlerResponse(rsp *http.Response) (*patchThreeScaleHandlerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &patchThreeScaleHandlerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreeScaleHandlers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostThreeScaleServiceResponse parses an HTTP response from a PostThreeScaleServiceWithResponse call
func ParsePostThreeScaleServiceResponse(rsp *http.Response) (*postThreeScaleServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &postThreeScaleServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreeScaleServiceRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteThreeScaleServiceResponse parses an HTTP response from a DeleteThreeScaleServiceWithResponse call
func ParseDeleteThreeScaleServiceResponse(rsp *http.Response) (*deleteThreeScaleServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteThreeScaleServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetThreeScaleServiceResponse parses an HTTP response from a GetThreeScaleServiceWithResponse call
func ParseGetThreeScaleServiceResponse(rsp *http.Response) (*getThreeScaleServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getThreeScaleServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreeScaleServiceRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchThreeScaleServiceResponse parses an HTTP response from a PatchThreeScaleServiceWithResponse call
func ParsePatchThreeScaleServiceResponse(rsp *http.Response) (*patchThreeScaleServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &patchThreeScaleServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreeScaleServiceRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {

			// HTTP status code
			Code    *int32  `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /)
	Root(ctx echo.Context) error

	// (GET /auth/info)
	AuthenticationInfo(ctx echo.Context) error

	// (GET /authenticate)
	Authenticate(ctx echo.Context) error

	// (POST /authenticate)
	OpenshiftCheckToken(ctx echo.Context) error

	// (GET /config)
	GetConfig(ctx echo.Context) error

	// (GET /grafana)
	GrafanaInfo(ctx echo.Context) error

	// (GET /istio/permissions)
	GetPermissions(ctx echo.Context) error

	// (DELETE /iter8/experiments/namespaces/{namespace}/name/{name})
	DeleteIter8Experiments(ctx echo.Context, namespace string, name string) error

	// (PATCH /iter8/experiments/{namespace}/name/{name})
	PatchIter8Experiments(ctx echo.Context, namespace string, name string) error
	// Endpoint to create new iter8 experiments for a given namespace.
	// (POST /iter8/namespaces/{namespace}/experiments)
	PostIter8Experiments(ctx echo.Context, namespace string) error

	// (GET /iter8/namespaces/{namespace}/experiments/{name})
	GetIter8Experiments(ctx echo.Context, namespace string, name string) error

	// (GET /jaeger)
	JaegerInfo(ctx echo.Context) error

	// (GET /logout)
	Logout(ctx echo.Context) error

	// (GET /mesh/tls)
	MeshTls(ctx echo.Context) error

	// (GET /namespaces)
	NamespaceList(ctx echo.Context) error
	// The backing JSON for a namespaces graph.
	// (GET /namespaces/graph)
	GraphNamespaces(ctx echo.Context, params GraphNamespacesParams) error

	// (GET /namespaces/{namespace}/applications/{app}/graph)
	GraphApp(ctx echo.Context, namespace string, app string, params GraphAppParams) error

	// (GET /namespaces/{namespace}/applications/{app}/versions/{version}/graph)
	GraphAppVersion(ctx echo.Context, namespace string, app string, version string, params GraphAppVersionParams) error

	// (GET /namespaces/{namespace}/apps)
	AppList(ctx echo.Context, namespace string) error

	// (GET /namespaces/{namespace}/apps/{app})
	AppDetails(ctx echo.Context, namespace string, app string) error

	// (GET /namespaces/{namespace}/apps/{app}/dashboard)
	AppDashboard(ctx echo.Context, namespace string, app string, params AppDashboardParams) error

	// (GET /namespaces/{namespace}/apps/{app}/health)
	AppHealth(ctx echo.Context, namespace string, app string, params AppHealthParams) error

	// (GET /namespaces/{namespace}/apps/{app}/metrics)
	AppMetrics(ctx echo.Context, namespace string, app string, params AppMetricsParams) error

	// (GET /namespaces/{namespace}/customdashboard/{dashboard})
	CustomDashboard(ctx echo.Context, namespace string, dashboard string, params CustomDashboardParams) error

	// (GET /namespaces/{namespace}/health)
	NamespaceHealth(ctx echo.Context, namespace string, params NamespaceHealthParams) error

	// (GET /namespaces/{namespace}/istio)
	IstioConfigList(ctx echo.Context, namespace string) error

	// (POST /namespaces/{namespace}/istio/{object_type})
	IstioConfigCreate(ctx echo.Context, namespace string, objectType string) error

	// (POST /namespaces/{namespace}/istio/{object_type}/{object_subtype})
	IstioConfigCreateSubtype(ctx echo.Context, namespace string, objectType string, objectSubtype string) error

	// (DELETE /namespaces/{namespace}/istio/{object_type}/{object_subtype}/{object})
	IstioConfigDeleteSubtype(ctx echo.Context, namespace string, objectType string, objectSubtype string, object string) error

	// (GET /namespaces/{namespace}/istio/{object_type}/{object_subtype}/{object})
	IstioConfigDetailsSubtype(ctx echo.Context, namespace string, objectType string, objectSubtype string, object string) error
	// Endpoint to update the Istio Config of an Istio object used for templates and adapters using Json Merge Patch strategy.
	// (PATCH /namespaces/{namespace}/istio/{object_type}/{object_subtype}/{object})
	IstioConfigUpdateSubtype(ctx echo.Context, namespace string, objectType string, objectSubtype string, object string) error

	// (DELETE /namespaces/{namespace}/istio/{object_type}/{object})
	IstioConfigDelete(ctx echo.Context, namespace string, objectType string, object string) error

	// (GET /namespaces/{namespace}/istio/{object_type}/{object})
	IstioConfigDetails(ctx echo.Context, namespace string, objectType string, object string) error
	// Endpoint to update the Istio Config of an Istio object used for templates and adapters using Json Merge Patch strategy.
	// (PATCH /namespaces/{namespace}/istio/{object_type}/{object})
	IstioConfigUpdate(ctx echo.Context, namespace string, objectType string, object string) error

	// (GET /namespaces/{namespace}/metrics)
	NamespaceMetrics(ctx echo.Context, namespace string) error

	// (GET /namespaces/{namespace}/pods/{pod})
	PodDetails(ctx echo.Context, namespace string, pod string) error

	// (GET /namespaces/{namespace}/pods/{pod}/logs)
	PodLogs(ctx echo.Context, namespace string, pod string, params PodLogsParams) error

	// (GET /namespaces/{namespace}/services)
	ServiceList(ctx echo.Context, namespace string) error

	// (GET /namespaces/{namespace}/services/{service})
	ServiceDetails(ctx echo.Context, namespace string, service string) error

	// (GET /namespaces/{namespace}/services/{service}/dashboard)
	ServiceDashboard(ctx echo.Context, namespace string, service string, params ServiceDashboardParams) error

	// (GET /namespaces/{namespace}/services/{service}/errortraces)
	ErrorTraces(ctx echo.Context, namespace string, service string) error
	// The backing JSON for a service node detail graph.
	// (GET /namespaces/{namespace}/services/{service}/graph)
	GraphService(ctx echo.Context, namespace string, service string, params GraphServiceParams) error

	// (GET /namespaces/{namespace}/services/{service}/health)
	ServiceHealth(ctx echo.Context, namespace string, service string, params ServiceHealthParams) error

	// (GET /namespaces/{namespace}/services/{service}/metrics)
	ServiceMetrics(ctx echo.Context, namespace string, service string, params ServiceMetricsParams) error

	// (GET /namespaces/{namespace}/services/{service}/spans)
	SpansList(ctx echo.Context, namespace string, service string) error

	// (GET /namespaces/{namespace}/services/{service}/traces)
	TracesDetail(ctx echo.Context, namespace string, service string) error

	// (GET /namespaces/{namespace}/tls)
	NamespaceTls(ctx echo.Context, namespace string) error

	// (GET /namespaces/{namespace}/validations)
	NamespaceValidations(ctx echo.Context, namespace string) error

	// (GET /namespaces/{namespace}/workloads)
	WorkloadList(ctx echo.Context, namespace string) error

	// (GET /namespaces/{namespace}/workloads/{workload})
	WorkloadDetails(ctx echo.Context, namespace string, workload string) error

	// (GET /namespaces/{namespace}/workloads/{workload}/dashboard)
	WorkloadDashboard(ctx echo.Context, namespace string, workload string, params WorkloadDashboardParams) error
	// The backing JSON for a workload node detail graph.
	// (GET /namespaces/{namespace}/workloads/{workload}/graph)
	GraphWorkload(ctx echo.Context, namespace string, workload string, params GraphWorkloadParams) error

	// (GET /namespaces/{namespace}/workloads/{workload}/health)
	WorkloadHealth(ctx echo.Context, namespace string, workload string, params WorkloadHealthParams) error

	// (GET /namespaces/{namespace}/workloads/{workload}/metrics)
	WorkloadMetrics(ctx echo.Context, namespace string, workload string, params WorkloadMetricsParams) error

	// (GET /status)
	GetStatus(ctx echo.Context) error

	// (GET /threescale)
	GetThreeScaleInfo(ctx echo.Context) error

	// (GET /threescale/handlers)
	GetThreeScaleHandlers(ctx echo.Context) error

	// (POST /threescale/handlers)
	PostThreeScaleHandlers(ctx echo.Context) error

	// (DELETE /threescale/handlers/{threescaleHandlerName})
	DeleteThreeScaleHandler(ctx echo.Context, threescaleHandlerName string) error

	// (PATCH /threescale/handlers/{threescaleHandlerName})
	PatchThreeScaleHandler(ctx echo.Context, threescaleHandlerName string) error

	// (POST /threescale/namespaces/{namespace}/services)
	PostThreeScaleService(ctx echo.Context, namespace string) error

	// (DELETE /threescale/namespaces/{namespace}/services/{service})
	DeleteThreeScaleService(ctx echo.Context, namespace string, service string) error

	// (GET /threescale/namespaces/{namespace}/services/{service})
	GetThreeScaleService(ctx echo.Context, namespace string, service string) error

	// (PATCH /threescale/namespaces/{namespace}/services/{service})
	PatchThreeScaleService(ctx echo.Context, namespace string, service string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Root converts echo context to params.
func (w *ServerInterfaceWrapper) Root(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Root(ctx)
	return err
}

// AuthenticationInfo converts echo context to params.
func (w *ServerInterfaceWrapper) AuthenticationInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthenticationInfo(ctx)
	return err
}

// Authenticate converts echo context to params.
func (w *ServerInterfaceWrapper) Authenticate(ctx echo.Context) error {
	var err error

	ctx.Set("authorization.Scopes", []string{"user", "password"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Authenticate(ctx)
	return err
}

// OpenshiftCheckToken converts echo context to params.
func (w *ServerInterfaceWrapper) OpenshiftCheckToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OpenshiftCheckToken(ctx)
	return err
}

// GetConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetConfig(ctx)
	return err
}

// GrafanaInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GrafanaInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GrafanaInfo(ctx)
	return err
}

// GetPermissions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPermissions(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPermissions(ctx)
	return err
}

// DeleteIter8Experiments converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteIter8Experiments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteIter8Experiments(ctx, namespace, name)
	return err
}

// PatchIter8Experiments converts echo context to params.
func (w *ServerInterfaceWrapper) PatchIter8Experiments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchIter8Experiments(ctx, namespace, name)
	return err
}

// PostIter8Experiments converts echo context to params.
func (w *ServerInterfaceWrapper) PostIter8Experiments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostIter8Experiments(ctx, namespace)
	return err
}

// GetIter8Experiments converts echo context to params.
func (w *ServerInterfaceWrapper) GetIter8Experiments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIter8Experiments(ctx, namespace, name)
	return err
}

// JaegerInfo converts echo context to params.
func (w *ServerInterfaceWrapper) JaegerInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.JaegerInfo(ctx)
	return err
}

// Logout converts echo context to params.
func (w *ServerInterfaceWrapper) Logout(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Logout(ctx)
	return err
}

// MeshTls converts echo context to params.
func (w *ServerInterfaceWrapper) MeshTls(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MeshTls(ctx)
	return err
}

// NamespaceList converts echo context to params.
func (w *ServerInterfaceWrapper) NamespaceList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NamespaceList(ctx)
	return err
}

// GraphNamespaces converts echo context to params.
func (w *ServerInterfaceWrapper) GraphNamespaces(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GraphNamespacesParams
	// ------------- Optional query parameter "appenders" -------------

	err = runtime.BindQueryParameter("form", true, false, "appenders", ctx.QueryParams(), &params.Appenders)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appenders: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "graphType" -------------

	err = runtime.BindQueryParameter("form", true, false, "graphType", ctx.QueryParams(), &params.GraphType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter graphType: %s", err))
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", ctx.QueryParams(), &params.GroupBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupBy: %s", err))
	}

	// ------------- Optional query parameter "injectServiceNodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "injectServiceNodes", ctx.QueryParams(), &params.InjectServiceNodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter injectServiceNodes: %s", err))
	}

	// ------------- Required query parameter "namespaces" -------------

	err = runtime.BindQueryParameter("form", true, true, "namespaces", ctx.QueryParams(), &params.Namespaces)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespaces: %s", err))
	}

	// ------------- Optional query parameter "queryTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "queryTime", ctx.QueryParams(), &params.QueryTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter queryTime: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GraphNamespaces(ctx, params)
	return err
}

// GraphApp converts echo context to params.
func (w *ServerInterfaceWrapper) GraphApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "app" -------------
	var app string

	err = runtime.BindStyledParameter("simple", false, "app", ctx.Param("app"), &app)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GraphAppParams
	// ------------- Optional query parameter "appenders" -------------

	err = runtime.BindQueryParameter("form", true, false, "appenders", ctx.QueryParams(), &params.Appenders)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appenders: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "graphType" -------------

	err = runtime.BindQueryParameter("form", true, false, "graphType", ctx.QueryParams(), &params.GraphType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter graphType: %s", err))
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", ctx.QueryParams(), &params.GroupBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupBy: %s", err))
	}

	// ------------- Optional query parameter "injectServiceNodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "injectServiceNodes", ctx.QueryParams(), &params.InjectServiceNodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter injectServiceNodes: %s", err))
	}

	// ------------- Optional query parameter "queryTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "queryTime", ctx.QueryParams(), &params.QueryTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter queryTime: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GraphApp(ctx, namespace, app, params)
	return err
}

// GraphAppVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GraphAppVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "app" -------------
	var app string

	err = runtime.BindStyledParameter("simple", false, "app", ctx.Param("app"), &app)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app: %s", err))
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameter("simple", false, "version", ctx.Param("version"), &version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GraphAppVersionParams
	// ------------- Optional query parameter "appenders" -------------

	err = runtime.BindQueryParameter("form", true, false, "appenders", ctx.QueryParams(), &params.Appenders)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appenders: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "graphType" -------------

	err = runtime.BindQueryParameter("form", true, false, "graphType", ctx.QueryParams(), &params.GraphType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter graphType: %s", err))
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", ctx.QueryParams(), &params.GroupBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupBy: %s", err))
	}

	// ------------- Optional query parameter "injectServiceNodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "injectServiceNodes", ctx.QueryParams(), &params.InjectServiceNodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter injectServiceNodes: %s", err))
	}

	// ------------- Optional query parameter "queryTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "queryTime", ctx.QueryParams(), &params.QueryTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter queryTime: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GraphAppVersion(ctx, namespace, app, version, params)
	return err
}

// AppList converts echo context to params.
func (w *ServerInterfaceWrapper) AppList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppList(ctx, namespace)
	return err
}

// AppDetails converts echo context to params.
func (w *ServerInterfaceWrapper) AppDetails(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "app" -------------
	var app string

	err = runtime.BindStyledParameter("simple", false, "app", ctx.Param("app"), &app)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppDetails(ctx, namespace, app)
	return err
}

// AppDashboard converts echo context to params.
func (w *ServerInterfaceWrapper) AppDashboard(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "app" -------------
	var app string

	err = runtime.BindStyledParameter("simple", false, "app", ctx.Param("app"), &app)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AppDashboardParams
	// ------------- Optional query parameter "avg" -------------

	err = runtime.BindQueryParameter("form", true, false, "avg", ctx.QueryParams(), &params.Avg)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter avg: %s", err))
	}

	// ------------- Optional query parameter "byLabels[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "byLabels[]", ctx.QueryParams(), &params.ByLabels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter byLabels[]: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "quantiles[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "quantiles[]", ctx.QueryParams(), &params.Quantiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quantiles[]: %s", err))
	}

	// ------------- Optional query parameter "rateFunc" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateFunc", ctx.QueryParams(), &params.RateFunc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateFunc: %s", err))
	}

	// ------------- Optional query parameter "rateInterval" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateInterval", ctx.QueryParams(), &params.RateInterval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateInterval: %s", err))
	}

	// ------------- Optional query parameter "requestProtocol" -------------

	err = runtime.BindQueryParameter("form", true, false, "requestProtocol", ctx.QueryParams(), &params.RequestProtocol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requestProtocol: %s", err))
	}

	// ------------- Optional query parameter "reporter" -------------

	err = runtime.BindQueryParameter("form", true, false, "reporter", ctx.QueryParams(), &params.Reporter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reporter: %s", err))
	}

	// ------------- Optional query parameter "step" -------------

	err = runtime.BindQueryParameter("form", true, false, "step", ctx.QueryParams(), &params.Step)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter step: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppDashboard(ctx, namespace, app, params)
	return err
}

// AppHealth converts echo context to params.
func (w *ServerInterfaceWrapper) AppHealth(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "app" -------------
	var app string

	err = runtime.BindStyledParameter("simple", false, "app", ctx.Param("app"), &app)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AppHealthParams
	// ------------- Optional query parameter "rateInterval" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateInterval", ctx.QueryParams(), &params.RateInterval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateInterval: %s", err))
	}

	// ------------- Optional query parameter "QueryTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "QueryTime", ctx.QueryParams(), &params.QueryTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter QueryTime: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppHealth(ctx, namespace, app, params)
	return err
}

// AppMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) AppMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "app" -------------
	var app string

	err = runtime.BindStyledParameter("simple", false, "app", ctx.Param("app"), &app)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AppMetricsParams
	// ------------- Optional query parameter "avg" -------------

	err = runtime.BindQueryParameter("form", true, false, "avg", ctx.QueryParams(), &params.Avg)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter avg: %s", err))
	}

	// ------------- Optional query parameter "byLabels[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "byLabels[]", ctx.QueryParams(), &params.ByLabels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter byLabels[]: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "filters[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filters[]", ctx.QueryParams(), &params.Filters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filters[]: %s", err))
	}

	// ------------- Optional query parameter "quantiles[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "quantiles[]", ctx.QueryParams(), &params.Quantiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quantiles[]: %s", err))
	}

	// ------------- Optional query parameter "rateFunc" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateFunc", ctx.QueryParams(), &params.RateFunc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateFunc: %s", err))
	}

	// ------------- Optional query parameter "rateInterval" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateInterval", ctx.QueryParams(), &params.RateInterval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateInterval: %s", err))
	}

	// ------------- Optional query parameter "requestProtocol" -------------

	err = runtime.BindQueryParameter("form", true, false, "requestProtocol", ctx.QueryParams(), &params.RequestProtocol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requestProtocol: %s", err))
	}

	// ------------- Optional query parameter "reporter" -------------

	err = runtime.BindQueryParameter("form", true, false, "reporter", ctx.QueryParams(), &params.Reporter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reporter: %s", err))
	}

	// ------------- Optional query parameter "step" -------------

	err = runtime.BindQueryParameter("form", true, false, "step", ctx.QueryParams(), &params.Step)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter step: %s", err))
	}

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", ctx.QueryParams(), &params.Version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppMetrics(ctx, namespace, app, params)
	return err
}

// CustomDashboard converts echo context to params.
func (w *ServerInterfaceWrapper) CustomDashboard(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "dashboard" -------------
	var dashboard string

	err = runtime.BindStyledParameter("simple", false, "dashboard", ctx.Param("dashboard"), &dashboard)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dashboard: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomDashboardParams
	// ------------- Optional query parameter "additionalLabels" -------------

	err = runtime.BindQueryParameter("form", true, false, "additionalLabels", ctx.QueryParams(), &params.AdditionalLabels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter additionalLabels: %s", err))
	}

	// ------------- Optional query parameter "avg" -------------

	err = runtime.BindQueryParameter("form", true, false, "avg", ctx.QueryParams(), &params.Avg)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter avg: %s", err))
	}

	// ------------- Optional query parameter "byLabels[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "byLabels[]", ctx.QueryParams(), &params.ByLabels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter byLabels[]: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "labelsFilters" -------------

	err = runtime.BindQueryParameter("form", true, false, "labelsFilters", ctx.QueryParams(), &params.LabelsFilters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter labelsFilters: %s", err))
	}

	// ------------- Optional query parameter "quantiles[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "quantiles[]", ctx.QueryParams(), &params.Quantiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quantiles[]: %s", err))
	}

	// ------------- Optional query parameter "rateFunc" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateFunc", ctx.QueryParams(), &params.RateFunc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateFunc: %s", err))
	}

	// ------------- Optional query parameter "rateInterval" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateInterval", ctx.QueryParams(), &params.RateInterval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateInterval: %s", err))
	}

	// ------------- Optional query parameter "step" -------------

	err = runtime.BindQueryParameter("form", true, false, "step", ctx.QueryParams(), &params.Step)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter step: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CustomDashboard(ctx, namespace, dashboard, params)
	return err
}

// NamespaceHealth converts echo context to params.
func (w *ServerInterfaceWrapper) NamespaceHealth(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params NamespaceHealthParams
	// ------------- Optional query parameter "rateInterval" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateInterval", ctx.QueryParams(), &params.RateInterval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateInterval: %s", err))
	}

	// ------------- Optional query parameter "QueryTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "QueryTime", ctx.QueryParams(), &params.QueryTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter QueryTime: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NamespaceHealth(ctx, namespace, params)
	return err
}

// IstioConfigList converts echo context to params.
func (w *ServerInterfaceWrapper) IstioConfigList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IstioConfigList(ctx, namespace)
	return err
}

// IstioConfigCreate converts echo context to params.
func (w *ServerInterfaceWrapper) IstioConfigCreate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "object_type" -------------
	var objectType string

	err = runtime.BindStyledParameter("simple", false, "object_type", ctx.Param("object_type"), &objectType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_type: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IstioConfigCreate(ctx, namespace, objectType)
	return err
}

// IstioConfigCreateSubtype converts echo context to params.
func (w *ServerInterfaceWrapper) IstioConfigCreateSubtype(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "object_type" -------------
	var objectType string

	err = runtime.BindStyledParameter("simple", false, "object_type", ctx.Param("object_type"), &objectType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_type: %s", err))
	}

	// ------------- Path parameter "object_subtype" -------------
	var objectSubtype string

	err = runtime.BindStyledParameter("simple", false, "object_subtype", ctx.Param("object_subtype"), &objectSubtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_subtype: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IstioConfigCreateSubtype(ctx, namespace, objectType, objectSubtype)
	return err
}

// IstioConfigDeleteSubtype converts echo context to params.
func (w *ServerInterfaceWrapper) IstioConfigDeleteSubtype(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "object_type" -------------
	var objectType string

	err = runtime.BindStyledParameter("simple", false, "object_type", ctx.Param("object_type"), &objectType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_type: %s", err))
	}

	// ------------- Path parameter "object_subtype" -------------
	var objectSubtype string

	err = runtime.BindStyledParameter("simple", false, "object_subtype", ctx.Param("object_subtype"), &objectSubtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_subtype: %s", err))
	}

	// ------------- Path parameter "object" -------------
	var object string

	err = runtime.BindStyledParameter("simple", false, "object", ctx.Param("object"), &object)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IstioConfigDeleteSubtype(ctx, namespace, objectType, objectSubtype, object)
	return err
}

// IstioConfigDetailsSubtype converts echo context to params.
func (w *ServerInterfaceWrapper) IstioConfigDetailsSubtype(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "object_type" -------------
	var objectType string

	err = runtime.BindStyledParameter("simple", false, "object_type", ctx.Param("object_type"), &objectType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_type: %s", err))
	}

	// ------------- Path parameter "object_subtype" -------------
	var objectSubtype string

	err = runtime.BindStyledParameter("simple", false, "object_subtype", ctx.Param("object_subtype"), &objectSubtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_subtype: %s", err))
	}

	// ------------- Path parameter "object" -------------
	var object string

	err = runtime.BindStyledParameter("simple", false, "object", ctx.Param("object"), &object)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IstioConfigDetailsSubtype(ctx, namespace, objectType, objectSubtype, object)
	return err
}

// IstioConfigUpdateSubtype converts echo context to params.
func (w *ServerInterfaceWrapper) IstioConfigUpdateSubtype(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "object_type" -------------
	var objectType string

	err = runtime.BindStyledParameter("simple", false, "object_type", ctx.Param("object_type"), &objectType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_type: %s", err))
	}

	// ------------- Path parameter "object_subtype" -------------
	var objectSubtype string

	err = runtime.BindStyledParameter("simple", false, "object_subtype", ctx.Param("object_subtype"), &objectSubtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_subtype: %s", err))
	}

	// ------------- Path parameter "object" -------------
	var object string

	err = runtime.BindStyledParameter("simple", false, "object", ctx.Param("object"), &object)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IstioConfigUpdateSubtype(ctx, namespace, objectType, objectSubtype, object)
	return err
}

// IstioConfigDelete converts echo context to params.
func (w *ServerInterfaceWrapper) IstioConfigDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "object_type" -------------
	var objectType string

	err = runtime.BindStyledParameter("simple", false, "object_type", ctx.Param("object_type"), &objectType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_type: %s", err))
	}

	// ------------- Path parameter "object" -------------
	var object string

	err = runtime.BindStyledParameter("simple", false, "object", ctx.Param("object"), &object)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IstioConfigDelete(ctx, namespace, objectType, object)
	return err
}

// IstioConfigDetails converts echo context to params.
func (w *ServerInterfaceWrapper) IstioConfigDetails(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "object_type" -------------
	var objectType string

	err = runtime.BindStyledParameter("simple", false, "object_type", ctx.Param("object_type"), &objectType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_type: %s", err))
	}

	// ------------- Path parameter "object" -------------
	var object string

	err = runtime.BindStyledParameter("simple", false, "object", ctx.Param("object"), &object)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IstioConfigDetails(ctx, namespace, objectType, object)
	return err
}

// IstioConfigUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) IstioConfigUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "object_type" -------------
	var objectType string

	err = runtime.BindStyledParameter("simple", false, "object_type", ctx.Param("object_type"), &objectType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_type: %s", err))
	}

	// ------------- Path parameter "object" -------------
	var object string

	err = runtime.BindStyledParameter("simple", false, "object", ctx.Param("object"), &object)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IstioConfigUpdate(ctx, namespace, objectType, object)
	return err
}

// NamespaceMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) NamespaceMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NamespaceMetrics(ctx, namespace)
	return err
}

// PodDetails converts echo context to params.
func (w *ServerInterfaceWrapper) PodDetails(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "pod" -------------
	var pod string

	err = runtime.BindStyledParameter("simple", false, "pod", ctx.Param("pod"), &pod)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pod: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PodDetails(ctx, namespace, pod)
	return err
}

// PodLogs converts echo context to params.
func (w *ServerInterfaceWrapper) PodLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "pod" -------------
	var pod string

	err = runtime.BindStyledParameter("simple", false, "pod", ctx.Param("pod"), &pod)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pod: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PodLogsParams
	// ------------- Optional query parameter "container" -------------

	err = runtime.BindQueryParameter("form", true, false, "container", ctx.QueryParams(), &params.Container)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter container: %s", err))
	}

	// ------------- Optional query parameter "sinceTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "sinceTime", ctx.QueryParams(), &params.SinceTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sinceTime: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PodLogs(ctx, namespace, pod, params)
	return err
}

// ServiceList converts echo context to params.
func (w *ServerInterfaceWrapper) ServiceList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ServiceList(ctx, namespace)
	return err
}

// ServiceDetails converts echo context to params.
func (w *ServerInterfaceWrapper) ServiceDetails(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "service" -------------
	var service string

	err = runtime.BindStyledParameter("simple", false, "service", ctx.Param("service"), &service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ServiceDetails(ctx, namespace, service)
	return err
}

// ServiceDashboard converts echo context to params.
func (w *ServerInterfaceWrapper) ServiceDashboard(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "service" -------------
	var service string

	err = runtime.BindStyledParameter("simple", false, "service", ctx.Param("service"), &service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ServiceDashboardParams
	// ------------- Optional query parameter "avg" -------------

	err = runtime.BindQueryParameter("form", true, false, "avg", ctx.QueryParams(), &params.Avg)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter avg: %s", err))
	}

	// ------------- Optional query parameter "byLabels[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "byLabels[]", ctx.QueryParams(), &params.ByLabels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter byLabels[]: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "quantiles[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "quantiles[]", ctx.QueryParams(), &params.Quantiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quantiles[]: %s", err))
	}

	// ------------- Optional query parameter "rateFunc" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateFunc", ctx.QueryParams(), &params.RateFunc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateFunc: %s", err))
	}

	// ------------- Optional query parameter "rateInterval" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateInterval", ctx.QueryParams(), &params.RateInterval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateInterval: %s", err))
	}

	// ------------- Optional query parameter "requestProtocol" -------------

	err = runtime.BindQueryParameter("form", true, false, "requestProtocol", ctx.QueryParams(), &params.RequestProtocol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requestProtocol: %s", err))
	}

	// ------------- Optional query parameter "reporter" -------------

	err = runtime.BindQueryParameter("form", true, false, "reporter", ctx.QueryParams(), &params.Reporter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reporter: %s", err))
	}

	// ------------- Optional query parameter "step" -------------

	err = runtime.BindQueryParameter("form", true, false, "step", ctx.QueryParams(), &params.Step)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter step: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ServiceDashboard(ctx, namespace, service, params)
	return err
}

// ErrorTraces converts echo context to params.
func (w *ServerInterfaceWrapper) ErrorTraces(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "service" -------------
	var service string

	err = runtime.BindStyledParameter("simple", false, "service", ctx.Param("service"), &service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ErrorTraces(ctx, namespace, service)
	return err
}

// GraphService converts echo context to params.
func (w *ServerInterfaceWrapper) GraphService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "service" -------------
	var service string

	err = runtime.BindStyledParameter("simple", false, "service", ctx.Param("service"), &service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GraphServiceParams
	// ------------- Optional query parameter "appenders" -------------

	err = runtime.BindQueryParameter("form", true, false, "appenders", ctx.QueryParams(), &params.Appenders)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appenders: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "graphType" -------------

	err = runtime.BindQueryParameter("form", true, false, "graphType", ctx.QueryParams(), &params.GraphType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter graphType: %s", err))
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", ctx.QueryParams(), &params.GroupBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupBy: %s", err))
	}

	// ------------- Optional query parameter "queryTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "queryTime", ctx.QueryParams(), &params.QueryTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter queryTime: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GraphService(ctx, namespace, service, params)
	return err
}

// ServiceHealth converts echo context to params.
func (w *ServerInterfaceWrapper) ServiceHealth(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "service" -------------
	var service string

	err = runtime.BindStyledParameter("simple", false, "service", ctx.Param("service"), &service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ServiceHealthParams
	// ------------- Optional query parameter "rateInterval" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateInterval", ctx.QueryParams(), &params.RateInterval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateInterval: %s", err))
	}

	// ------------- Optional query parameter "QueryTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "QueryTime", ctx.QueryParams(), &params.QueryTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter QueryTime: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ServiceHealth(ctx, namespace, service, params)
	return err
}

// ServiceMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) ServiceMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "service" -------------
	var service string

	err = runtime.BindStyledParameter("simple", false, "service", ctx.Param("service"), &service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ServiceMetricsParams
	// ------------- Optional query parameter "avg" -------------

	err = runtime.BindQueryParameter("form", true, false, "avg", ctx.QueryParams(), &params.Avg)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter avg: %s", err))
	}

	// ------------- Optional query parameter "byLabels[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "byLabels[]", ctx.QueryParams(), &params.ByLabels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter byLabels[]: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "filters[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filters[]", ctx.QueryParams(), &params.Filters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filters[]: %s", err))
	}

	// ------------- Optional query parameter "quantiles[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "quantiles[]", ctx.QueryParams(), &params.Quantiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quantiles[]: %s", err))
	}

	// ------------- Optional query parameter "rateFunc" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateFunc", ctx.QueryParams(), &params.RateFunc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateFunc: %s", err))
	}

	// ------------- Optional query parameter "rateInterval" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateInterval", ctx.QueryParams(), &params.RateInterval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateInterval: %s", err))
	}

	// ------------- Optional query parameter "requestProtocol" -------------

	err = runtime.BindQueryParameter("form", true, false, "requestProtocol", ctx.QueryParams(), &params.RequestProtocol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requestProtocol: %s", err))
	}

	// ------------- Optional query parameter "reporter" -------------

	err = runtime.BindQueryParameter("form", true, false, "reporter", ctx.QueryParams(), &params.Reporter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reporter: %s", err))
	}

	// ------------- Optional query parameter "step" -------------

	err = runtime.BindQueryParameter("form", true, false, "step", ctx.QueryParams(), &params.Step)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter step: %s", err))
	}

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", ctx.QueryParams(), &params.Version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ServiceMetrics(ctx, namespace, service, params)
	return err
}

// SpansList converts echo context to params.
func (w *ServerInterfaceWrapper) SpansList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "service" -------------
	var service string

	err = runtime.BindStyledParameter("simple", false, "service", ctx.Param("service"), &service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpansList(ctx, namespace, service)
	return err
}

// TracesDetail converts echo context to params.
func (w *ServerInterfaceWrapper) TracesDetail(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "service" -------------
	var service string

	err = runtime.BindStyledParameter("simple", false, "service", ctx.Param("service"), &service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TracesDetail(ctx, namespace, service)
	return err
}

// NamespaceTls converts echo context to params.
func (w *ServerInterfaceWrapper) NamespaceTls(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NamespaceTls(ctx, namespace)
	return err
}

// NamespaceValidations converts echo context to params.
func (w *ServerInterfaceWrapper) NamespaceValidations(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NamespaceValidations(ctx, namespace)
	return err
}

// WorkloadList converts echo context to params.
func (w *ServerInterfaceWrapper) WorkloadList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WorkloadList(ctx, namespace)
	return err
}

// WorkloadDetails converts echo context to params.
func (w *ServerInterfaceWrapper) WorkloadDetails(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "workload" -------------
	var workload string

	err = runtime.BindStyledParameter("simple", false, "workload", ctx.Param("workload"), &workload)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workload: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WorkloadDetails(ctx, namespace, workload)
	return err
}

// WorkloadDashboard converts echo context to params.
func (w *ServerInterfaceWrapper) WorkloadDashboard(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "workload" -------------
	var workload string

	err = runtime.BindStyledParameter("simple", false, "workload", ctx.Param("workload"), &workload)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workload: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params WorkloadDashboardParams
	// ------------- Optional query parameter "avg" -------------

	err = runtime.BindQueryParameter("form", true, false, "avg", ctx.QueryParams(), &params.Avg)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter avg: %s", err))
	}

	// ------------- Optional query parameter "byLabels[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "byLabels[]", ctx.QueryParams(), &params.ByLabels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter byLabels[]: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "quantiles[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "quantiles[]", ctx.QueryParams(), &params.Quantiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quantiles[]: %s", err))
	}

	// ------------- Optional query parameter "rateFunc" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateFunc", ctx.QueryParams(), &params.RateFunc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateFunc: %s", err))
	}

	// ------------- Optional query parameter "rateInterval" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateInterval", ctx.QueryParams(), &params.RateInterval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateInterval: %s", err))
	}

	// ------------- Optional query parameter "requestProtocol" -------------

	err = runtime.BindQueryParameter("form", true, false, "requestProtocol", ctx.QueryParams(), &params.RequestProtocol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requestProtocol: %s", err))
	}

	// ------------- Optional query parameter "reporter" -------------

	err = runtime.BindQueryParameter("form", true, false, "reporter", ctx.QueryParams(), &params.Reporter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reporter: %s", err))
	}

	// ------------- Optional query parameter "step" -------------

	err = runtime.BindQueryParameter("form", true, false, "step", ctx.QueryParams(), &params.Step)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter step: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WorkloadDashboard(ctx, namespace, workload, params)
	return err
}

// GraphWorkload converts echo context to params.
func (w *ServerInterfaceWrapper) GraphWorkload(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "workload" -------------
	var workload string

	err = runtime.BindStyledParameter("simple", false, "workload", ctx.Param("workload"), &workload)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workload: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GraphWorkloadParams
	// ------------- Optional query parameter "appenders" -------------

	err = runtime.BindQueryParameter("form", true, false, "appenders", ctx.QueryParams(), &params.Appenders)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appenders: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "graphType" -------------

	err = runtime.BindQueryParameter("form", true, false, "graphType", ctx.QueryParams(), &params.GraphType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter graphType: %s", err))
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", ctx.QueryParams(), &params.GroupBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupBy: %s", err))
	}

	// ------------- Optional query parameter "injectServiceNodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "injectServiceNodes", ctx.QueryParams(), &params.InjectServiceNodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter injectServiceNodes: %s", err))
	}

	// ------------- Optional query parameter "queryTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "queryTime", ctx.QueryParams(), &params.QueryTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter queryTime: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GraphWorkload(ctx, namespace, workload, params)
	return err
}

// WorkloadHealth converts echo context to params.
func (w *ServerInterfaceWrapper) WorkloadHealth(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "workload" -------------
	var workload string

	err = runtime.BindStyledParameter("simple", false, "workload", ctx.Param("workload"), &workload)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workload: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params WorkloadHealthParams
	// ------------- Optional query parameter "rateInterval" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateInterval", ctx.QueryParams(), &params.RateInterval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateInterval: %s", err))
	}

	// ------------- Optional query parameter "QueryTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "QueryTime", ctx.QueryParams(), &params.QueryTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter QueryTime: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WorkloadHealth(ctx, namespace, workload, params)
	return err
}

// WorkloadMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) WorkloadMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "workload" -------------
	var workload string

	err = runtime.BindStyledParameter("simple", false, "workload", ctx.Param("workload"), &workload)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workload: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params WorkloadMetricsParams
	// ------------- Optional query parameter "avg" -------------

	err = runtime.BindQueryParameter("form", true, false, "avg", ctx.QueryParams(), &params.Avg)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter avg: %s", err))
	}

	// ------------- Optional query parameter "byLabels[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "byLabels[]", ctx.QueryParams(), &params.ByLabels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter byLabels[]: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", ctx.QueryParams(), &params.Duration)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter duration: %s", err))
	}

	// ------------- Optional query parameter "filters[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filters[]", ctx.QueryParams(), &params.Filters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filters[]: %s", err))
	}

	// ------------- Optional query parameter "quantiles[]" -------------

	err = runtime.BindQueryParameter("form", false, false, "quantiles[]", ctx.QueryParams(), &params.Quantiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quantiles[]: %s", err))
	}

	// ------------- Optional query parameter "rateFunc" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateFunc", ctx.QueryParams(), &params.RateFunc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateFunc: %s", err))
	}

	// ------------- Optional query parameter "rateInterval" -------------

	err = runtime.BindQueryParameter("form", true, false, "rateInterval", ctx.QueryParams(), &params.RateInterval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rateInterval: %s", err))
	}

	// ------------- Optional query parameter "requestProtocol" -------------

	err = runtime.BindQueryParameter("form", true, false, "requestProtocol", ctx.QueryParams(), &params.RequestProtocol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requestProtocol: %s", err))
	}

	// ------------- Optional query parameter "reporter" -------------

	err = runtime.BindQueryParameter("form", true, false, "reporter", ctx.QueryParams(), &params.Reporter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reporter: %s", err))
	}

	// ------------- Optional query parameter "step" -------------

	err = runtime.BindQueryParameter("form", true, false, "step", ctx.QueryParams(), &params.Step)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter step: %s", err))
	}

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", ctx.QueryParams(), &params.Version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WorkloadMetrics(ctx, namespace, workload, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// GetThreeScaleInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetThreeScaleInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetThreeScaleInfo(ctx)
	return err
}

// GetThreeScaleHandlers converts echo context to params.
func (w *ServerInterfaceWrapper) GetThreeScaleHandlers(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetThreeScaleHandlers(ctx)
	return err
}

// PostThreeScaleHandlers converts echo context to params.
func (w *ServerInterfaceWrapper) PostThreeScaleHandlers(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostThreeScaleHandlers(ctx)
	return err
}

// DeleteThreeScaleHandler converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteThreeScaleHandler(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "threescaleHandlerName" -------------
	var threescaleHandlerName string

	err = runtime.BindStyledParameter("simple", false, "threescaleHandlerName", ctx.Param("threescaleHandlerName"), &threescaleHandlerName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter threescaleHandlerName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteThreeScaleHandler(ctx, threescaleHandlerName)
	return err
}

// PatchThreeScaleHandler converts echo context to params.
func (w *ServerInterfaceWrapper) PatchThreeScaleHandler(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "threescaleHandlerName" -------------
	var threescaleHandlerName string

	err = runtime.BindStyledParameter("simple", false, "threescaleHandlerName", ctx.Param("threescaleHandlerName"), &threescaleHandlerName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter threescaleHandlerName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchThreeScaleHandler(ctx, threescaleHandlerName)
	return err
}

// PostThreeScaleService converts echo context to params.
func (w *ServerInterfaceWrapper) PostThreeScaleService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostThreeScaleService(ctx, namespace)
	return err
}

// DeleteThreeScaleService converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteThreeScaleService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "service" -------------
	var service string

	err = runtime.BindStyledParameter("simple", false, "service", ctx.Param("service"), &service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteThreeScaleService(ctx, namespace, service)
	return err
}

// GetThreeScaleService converts echo context to params.
func (w *ServerInterfaceWrapper) GetThreeScaleService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "service" -------------
	var service string

	err = runtime.BindStyledParameter("simple", false, "service", ctx.Param("service"), &service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetThreeScaleService(ctx, namespace, service)
	return err
}

// PatchThreeScaleService converts echo context to params.
func (w *ServerInterfaceWrapper) PatchThreeScaleService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "namespace" -------------
	var namespace string

	err = runtime.BindStyledParameter("simple", false, "namespace", ctx.Param("namespace"), &namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Path parameter "service" -------------
	var service string

	err = runtime.BindStyledParameter("simple", false, "service", ctx.Param("service"), &service)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchThreeScaleService(ctx, namespace, service)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/", wrapper.Root)
	router.GET("/auth/info", wrapper.AuthenticationInfo)
	router.GET("/authenticate", wrapper.Authenticate)
	router.POST("/authenticate", wrapper.OpenshiftCheckToken)
	router.GET("/config", wrapper.GetConfig)
	router.GET("/grafana", wrapper.GrafanaInfo)
	router.GET("/istio/permissions", wrapper.GetPermissions)
	router.DELETE("/iter8/experiments/namespaces/:namespace/name/:name", wrapper.DeleteIter8Experiments)
	router.PATCH("/iter8/experiments/:namespace/name/:name", wrapper.PatchIter8Experiments)
	router.POST("/iter8/namespaces/:namespace/experiments", wrapper.PostIter8Experiments)
	router.GET("/iter8/namespaces/:namespace/experiments/:name", wrapper.GetIter8Experiments)
	router.GET("/jaeger", wrapper.JaegerInfo)
	router.GET("/logout", wrapper.Logout)
	router.GET("/mesh/tls", wrapper.MeshTls)
	router.GET("/namespaces", wrapper.NamespaceList)
	router.GET("/namespaces/graph", wrapper.GraphNamespaces)
	router.GET("/namespaces/:namespace/applications/:app/graph", wrapper.GraphApp)
	router.GET("/namespaces/:namespace/applications/:app/versions/:version/graph", wrapper.GraphAppVersion)
	router.GET("/namespaces/:namespace/apps", wrapper.AppList)
	router.GET("/namespaces/:namespace/apps/:app", wrapper.AppDetails)
	router.GET("/namespaces/:namespace/apps/:app/dashboard", wrapper.AppDashboard)
	router.GET("/namespaces/:namespace/apps/:app/health", wrapper.AppHealth)
	router.GET("/namespaces/:namespace/apps/:app/metrics", wrapper.AppMetrics)
	router.GET("/namespaces/:namespace/customdashboard/:dashboard", wrapper.CustomDashboard)
	router.GET("/namespaces/:namespace/health", wrapper.NamespaceHealth)
	router.GET("/namespaces/:namespace/istio", wrapper.IstioConfigList)
	router.POST("/namespaces/:namespace/istio/:object_type", wrapper.IstioConfigCreate)
	router.POST("/namespaces/:namespace/istio/:object_type/:object_subtype", wrapper.IstioConfigCreateSubtype)
	router.DELETE("/namespaces/:namespace/istio/:object_type/:object_subtype/:object", wrapper.IstioConfigDeleteSubtype)
	router.GET("/namespaces/:namespace/istio/:object_type/:object_subtype/:object", wrapper.IstioConfigDetailsSubtype)
	router.PATCH("/namespaces/:namespace/istio/:object_type/:object_subtype/:object", wrapper.IstioConfigUpdateSubtype)
	router.DELETE("/namespaces/:namespace/istio/:object_type/:object", wrapper.IstioConfigDelete)
	router.GET("/namespaces/:namespace/istio/:object_type/:object", wrapper.IstioConfigDetails)
	router.PATCH("/namespaces/:namespace/istio/:object_type/:object", wrapper.IstioConfigUpdate)
	router.GET("/namespaces/:namespace/metrics", wrapper.NamespaceMetrics)
	router.GET("/namespaces/:namespace/pods/:pod", wrapper.PodDetails)
	router.GET("/namespaces/:namespace/pods/:pod/logs", wrapper.PodLogs)
	router.GET("/namespaces/:namespace/services", wrapper.ServiceList)
	router.GET("/namespaces/:namespace/services/:service", wrapper.ServiceDetails)
	router.GET("/namespaces/:namespace/services/:service/dashboard", wrapper.ServiceDashboard)
	router.GET("/namespaces/:namespace/services/:service/errortraces", wrapper.ErrorTraces)
	router.GET("/namespaces/:namespace/services/:service/graph", wrapper.GraphService)
	router.GET("/namespaces/:namespace/services/:service/health", wrapper.ServiceHealth)
	router.GET("/namespaces/:namespace/services/:service/metrics", wrapper.ServiceMetrics)
	router.GET("/namespaces/:namespace/services/:service/spans", wrapper.SpansList)
	router.GET("/namespaces/:namespace/services/:service/traces", wrapper.TracesDetail)
	router.GET("/namespaces/:namespace/tls", wrapper.NamespaceTls)
	router.GET("/namespaces/:namespace/validations", wrapper.NamespaceValidations)
	router.GET("/namespaces/:namespace/workloads", wrapper.WorkloadList)
	router.GET("/namespaces/:namespace/workloads/:workload", wrapper.WorkloadDetails)
	router.GET("/namespaces/:namespace/workloads/:workload/dashboard", wrapper.WorkloadDashboard)
	router.GET("/namespaces/:namespace/workloads/:workload/graph", wrapper.GraphWorkload)
	router.GET("/namespaces/:namespace/workloads/:workload/health", wrapper.WorkloadHealth)
	router.GET("/namespaces/:namespace/workloads/:workload/metrics", wrapper.WorkloadMetrics)
	router.GET("/status", wrapper.GetStatus)
	router.GET("/threescale", wrapper.GetThreeScaleInfo)
	router.GET("/threescale/handlers", wrapper.GetThreeScaleHandlers)
	router.POST("/threescale/handlers", wrapper.PostThreeScaleHandlers)
	router.DELETE("/threescale/handlers/:threescaleHandlerName", wrapper.DeleteThreeScaleHandler)
	router.PATCH("/threescale/handlers/:threescaleHandlerName", wrapper.PatchThreeScaleHandler)
	router.POST("/threescale/namespaces/:namespace/services", wrapper.PostThreeScaleService)
	router.DELETE("/threescale/namespaces/:namespace/services/:service", wrapper.DeleteThreeScaleService)
	router.GET("/threescale/namespaces/:namespace/services/:service", wrapper.GetThreeScaleService)
	router.PATCH("/threescale/namespaces/:namespace/services/:service", wrapper.PatchThreeScaleService)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"tXSpEC5RAgA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

